## 1. 项目介绍

### 1.1 技术点

前端：

- Thymeleaf
- Bootstrap
- Jquery

后端：

- SpringBoot
- MyBatisPlus

中间件：

- Redis
- RabbitMQ

### 1.2 项目步骤

1. 项目搭建
2. 分布式 Session
3. 秒杀功能
4. 压力测试
5. 页面优化
6. 服务优化
7. 接口安全



### 1.3 学习目标

![image-20220706144505566](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706144505566.png)

## 2. 如何设计一个秒杀系统

[如何设计秒杀系统](https://cloud.tencent.com/developer/article/1863530)

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/9b1ed608a00f69b309fa4be08fc41056.jpeg)

## 3. 项目搭建

> 新建项目

新建 SpringBoot 项目，添加相关依赖，编写一个 Controller 测试环境是否搭建好。



> 编写配置文件

新建 `application.yml` ，编写配置文件：

```yaml
spring:
  thymeleaf:
    # 关闭缓存
    cache: false
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/seckill?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: 123456
    hikari:
      pool-name: DateHikariCP
      # 最小空闲连接数
      minimum-idle: 5
      # 空闲连接存活最大时间，默认600000s
      idle-timeout: 180000
      # 最大连接数，默认10
      maximum-pool-size: 10
      # 从连接池返回的连接自动提交
      auto-commit: true
      # 连接最大存活时间，0表示永久存活
      max-lifetime: 1800000
      # 连接超时时间，默认30000
      connection-timeout: 30000
      # 测试连接是否可用 的查询语句
      connection-test-query: SELECT 1

mybatis-plus:
  # 配置Mapper.xml映射文件位置
  mapper-locations: classpath*:/mapper/*Mapper.xml
  # 实体类自动起别名
  type-aliases-package: com.run.seckill.pojo

# MyBatis SQL打印（方法接口所在包，不是Mapper.xml所在包）
logging:
  level:
    com.run.seckill.mapper: debug

```



> 创建数据库

先创建一个 `seckill` 数据库，新建一张 `t_user` 表，添加相应的字段。

![image-20220706174842450](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706174842450.png)

> MyBatisPlus 逆向工程

首先需要通过逆向工程基于 `t_user` 表生产对应的 POJO、Mapper、Service、ServiceImpl、Controller
等类，项目中使用了MybatisPlus，所以逆向工程也是用了MybatisPlus提供的AutoGenerator，代码如
下。具体可去官网查看：

把它建成一个新项目，以后写项目时也可以直接使用。

新建 SpringBoot 项目，只添加一个 Web 依赖，导入 MyBatisPlus 逆向工程依赖：

```xml
	<dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.4.1</version>
        </dependency>
	<!--模板引擎-->
        <dependency>
            <groupId>org.freemarker</groupId>
            <artifactId>freemarker</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
```

新建 `CodeGenerator.java` 类：

```java
/**
 * 执行 main 方法控制台输入模块表名回车自动生成对应项目目录中
 *
 * @author AruNi_Lu
 * @since 1.0.0
 */
public class CodeGenerator {
    /**
     * <p>
     * 读取控制台内容
     * </p>
     */
    public static String scanner(String tip) {
        Scanner scanner = new Scanner(System.in);
        StringBuilder help = new StringBuilder();
        help.append("请输入" + tip + "：");
        System.out.println(help.toString());
        if (scanner.hasNext()) {
            String ipt = scanner.next();
            if (StringUtils.isNotBlank(ipt)) {
                return ipt;
            }
        }
        throw new MybatisPlusException("请输入正确的" + tip + "！");
    }

    public static void main(String[] args) {
        // 代码生成器
        AutoGenerator mpg = new AutoGenerator();
        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        gc.setOutputDir(projectPath + "/src/main/java");
        //作者
        gc.setAuthor("AruNi_Lu");
        //打开输出目录
        gc.setOpen(false);
        //xml开启 BaseResultMap
        gc.setBaseResultMap(true);
        //xml 开启BaseColumnList
        gc.setBaseColumnList(true);
        //日期格式，采用Date
        gc.setDateType(DateType.ONLY_DATE);
        mpg.setGlobalConfig(gc);
        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/seckill?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("123456");
        mpg.setDataSource(dsc);
        // 包配置
        PackageConfig pc = new PackageConfig();
        pc.setParent("com.run.seckill")
                .setEntity("pojo")
                .setMapper("mapper")
                .setService("service")
                .setServiceImpl("service.impl")
                .setController("controller");
        mpg.setPackageInfo(pc);
        // 自定义配置
        InjectionConfig cfg = new InjectionConfig() {
            @Override
            public void initMap() {
                // to do nothing
                Map<String,Object> map = new HashMap<>();
                map.put("date1","1.0.0");
                this.setMap(map);
            }
        };
        // 如果模板引擎是 freemarker
        String templatePath = "/templates/mapper.xml.ftl";
        // 如果模板引擎是 velocity
        // String templatePath = "/templates/mapper.xml.vm";
        // 自定义输出配置
        List<FileOutConfig> focList = new ArrayList<>();
        // 自定义配置会被优先输出
        focList.add(new FileOutConfig(templatePath) {
            @Override
            public String outputFile(TableInfo tableInfo) {
                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
                return projectPath + "/src/main/resources/mapper/" +
                        tableInfo.getEntityName() + "Mapper"
                        + StringPool.DOT_XML;
            }
        });
        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        // 可以自定义 配置模板
//        TemplateConfig templateConfig = new TemplateConfig()
//                .setEntity("templates/entity.java")
//                .setMapper("templates/mapper.java")
//                .setService("templates/service.java")
//                .setServiceImpl("templates/serviceImpl.java")
//                .setController("templates/controller.java");
//        templateConfig.setXml(null);
//        mpg.setTemplate(templateConfig);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        //数据库表映射到实体的命名策略
        strategy.setNaming(NamingStrategy.underline_to_camel);
        //数据库表字段映射到实体的命名策略
        strategy.setColumnNaming(NamingStrategy.underline_to_camel);
        //lombok模型
        strategy.setEntityLombokModel(true);
        //生成 @RestController 控制器
        // strategy.setRestControllerStyle(true);
        strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));
        strategy.setControllerMappingHyphenStyle(true);
        //表前缀
        strategy.setTablePrefix("t_");
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());
        mpg.execute();
    }
}
```

运行，输入表名，即可生成对应的代码，然后拷贝进项目即可：

![image-20220706183451853](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706183451853.png)



## 4. 分布式会话

### 4.1 实现登录功能

#### MD5加密类

password 采用两次 MD5 加密：

- 在客户端将明文密码传到后端时，加密一次
- 后端将 password 存入数据库时，再加密一次

用户端 MD5 加密是为了防止用户密码在网络中明文传输，服务端 MD5 加密是为了提高密码安全性，双
重保险。

新建 `utils` 包，创建 `MD5` 类，编写加密代码：

```java
/**
 * @author AruNi_Lu
 * @data 2022/7/6
 */
public class MD5Util {

    // md5加密
    public static String md5(String src) {
        return DigestUtils.md5Hex(src);
    }

    // 这个salt是和前端共用的，第一次加密是前端加的
    private static final String salt = "1a2b3c4d";

    // 第一次加密，网页输入的密码传到后端来时加密
    public static String inputPwdEncryption(String inputPwd) {
        // 用部分salt加密，增加安全性
        String str = salt.charAt(0) + salt.charAt(2) + inputPwd + salt.charAt(5);
        return md5(str);
    }

    // 第二次加密，存入数据库时加密；这个salt是数据库中的salt字段
    public static String BackendPwdEncryption(String backendPwd, String salt) {
        // 此处用的salt是数据库的，不同上面
        String str = salt.charAt(0) + salt.charAt(2) + backendPwd + salt.charAt(5);
        return md5(str);
    }

    // 真正调用的加密方法
    public static String inputPwdToDBPwd(String inputPwd, String salt) {
        String backendPwd = inputPwdEncryption(inputPwd); // 第一次加密
        return BackendPwdEncryption(backendPwd, salt);     // 返回第二次加密的密码
    }

    // 测试
    public static void main(String[] args) {
        // 72100a46bad3df5e9a23ab6119c137f1
        System.out.println(inputPwdEncryption("123456"));
        System.out.println(BackendPwdEncryption("72100a46bad3df5e9a23ab6119c137f1", "1a2b3c"));
        System.out.println(inputPwdToDBPwd("123456", "1a2b3c"));
    }
}
```



#### Vo 包

Vo：接受前端传来的参数，或者返回给前端的对象。

`vo.param.LoginVo.java` 登录参数：

```java
@Data
public class LoginVo {
    private String mobile;
    private String password;
}
```

`vo.RespBean.java` 公共返回对象，用于响应数据给前端：

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class RespBean {
    private long code;
    private String message;
    private Object obj;

    public static RespBean success() {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), null);
    }

    public static RespBean success(Object obj) {
        return new RespBean(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), obj);
    }

    public static RespBean error(RespBeanEnum respBeanEnum) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), null);
    }

    public static RespBean error(RespBeanEnum respBeanEnum, Object obj) {
        return new RespBean(respBeanEnum.getCode(), respBeanEnum.getMessage(), obj);
    }
}
```

`vo.RespBeanEnum.java` 公共返回对象枚举，用于定义一些枚举类型的状态码：

```java
@Getter
@AllArgsConstructor
@ToString
public enum RespBeanEnum {
    // 通用状态码
    SUCCESS(200, "成功"),
    ERROR(500, "服务端异常"),

    // 登录模块
    LOGIN_ERROR(500210, "用户名或密码不正确"),

    // 校验手机号错误
    MOBILE_ERROR(500211, "手机号码格式不正确")
    ;

    private final Integer code;
    private final String message;
}
```



#### 登录功能

`LoginController.java`：

```java
@Controller
@RequestMapping("/login")
@Slf4j
public class LoginController {

    @Autowired
    private IUserService userService;

    /**
     * 跳转到登录页面
     * @return
     */
    @RequestMapping("/toLogin")
    public String toLogin() {
        return "login";
    }

    /**
     * 登录功能
     * @param loginVo
     * @return
     */
    @RequestMapping("/doLogin")
    @ResponseBody
    public RespBean doLogin(LoginVo loginVo) {
        log.info("{}", loginVo);    // 查看前端传过来的参数
        return userService.login(loginVo);
    }

}
```



校验手机号的 `ValidatorUtil` 工具类：

```java
/**
 * @author AruNi_Lu
 * @data 2022/7/6
 * 登录功能 校验工具类
 */
public class ValidatorUtil {

    // 正则表达式来规定手机号的形式，以1开头，第2位3-9，后面在0-9之间的任意9位数字
    private static final Pattern mobile_pattern = Pattern.compile("^1[3-9][0-9]{9}$");

    // 校验手机号码
    public static boolean isMobile(String mobile) {
        if (StringUtils.isEmpty(mobile)) {
            return false;
        }
        // 与正则表达式进行匹配
        Matcher matcher = mobile_pattern.matcher(mobile);
        return matcher.matches();
    }
}
```

登录校验业务，`UserServiceImpl.java`：

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public RespBean login(LoginVo loginVo) {
        String mobile = loginVo.getMobile();
        String pwd = loginVo.getPassword();
        if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(pwd)) {
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        // 校验手机号
        if (!ValidatorUtil.isMobile(mobile)) {
            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
        }

        // mobile就是id
        User user = userMapper.selectById(mobile);
        if (user == null) {
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        // 判断密码是否正确，前端传过来的密码已经加密过一次，只需要将用户的salt和pwd传进后端加密方法里，看得到的二次加密的密码是否和DB中一致
        if (!MD5Util.BackendPwdEncryption(pwd, user.getSalt()).equals(user.getPassword())) {
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        return RespBean.success();
    }
}
```

mapper 使用 MybatisPlus 自带的就够用了，不用自己写。

`login.html`：

```html
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
    <!-- jquery -->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}"/>
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- jquery-validator -->
    <script type="text/javascript" th:src="@{/jquery-validation/jquery.validate.min.js}"></script>
    <script type="text/javascript" th:src="@{/jquery-validation/localization/messages_zh.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
    <!-- md5.js -->
    <script type="text/javascript" th:src="@{/js/md5.min.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<form name="loginForm" id="loginForm" method="post" style="width:50%; margin:0 auto">

    <h2 style="text-align:center; margin-bottom: 20px">用户登录</h2>

    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入手机号码</label>
            <div class="col-md-5">
                <input id="mobile" name="mobile" class="form-control" type="text" placeholder="手机号码" required="true"
                />
                <!--取消位数限制 minlength="11" maxlength="11"-->
            </div>
            <div class="col-md-1">
            </div>
        </div>
    </div>

    <div class="form-group">
        <div class="row">
            <label class="form-label col-md-4">请输入密码</label>
            <div class="col-md-5">
                <input id="password" name="password" class="form-control" type="password" placeholder="密码" required="true"/>
                <!--取消位数限制 minlength="6" maxlength="16"-->
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-5">
            <button class="btn btn-primary btn-block" type="reset" onclick="reset()">重置</button>
        </div>
        <div class="col-md-5">
            <button class="btn btn-primary btn-block" type="submit" onclick="login()">登录</button>
        </div>
    </div>
</form>
</body>
<script>
    function login() {
        // 先调用validate 检验
        $("#loginForm").validate({
            submitHandler: function (form) {
                doLogin();  // 检验成功后调用doLogin方法
            }
        });
    }

    // 登录方法
    function doLogin() {
        g_showLoading();    // common.js 里的加载框

        var inputPass = $("#password").val();
        var salt = g_passsword_salt;    // salt，在 common.js 中
        // 此处的加密要和后端的一样
        var str = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5);
        var password = md5(str);

        $.ajax({
            url: "/login/doLogin",      // 调用后端接口
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function (data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg("成功");
                    console.log(data);
                    document.cookie = "userTicket=" + data.object;
                    window.location.href = "/goods/toList";
                } else {
                    layer.msg(data.message);
                }
            },
            error: function () {
                layer.closeAll();
            }
        });
    }
</script>
</html>
```



#### 测试

![image-20220706211409967](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706211409967.png)

![image-20220706211456327](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706211456327.png)

![image-20220706213129279](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220706213129279.png)



### 4.2 参数校验

每个类都写大量的健壮性判断过于麻烦，我们可以使用 validation 简化我们的代码。

导入依赖：

```xml
	<!--validation 校验-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
```

![image-20220708111036110](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220708111036110.png)

可以看到，validatior 有许多校验规则的注解，当然也可以自己自定义校验规则。下面我们就来自定义上面的手机号码校验规则的注解。



**1、先创建一个注解**：

新建 `validator` 包，创建 `IsMobile.java`，根据 validator 自带的注解，进行仿写：

```java
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(
        validatedBy = {IsMobileValidator.class}		// 下面的校验规则类
)
public @interface IsMobile {

    boolean required() default true;        // 是否必填，默认true

    String message() default "手机号码格式错误";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```



**2、自定义手机号码校验规则**：

在 `validator` 包下新建 `IsMobileValidator.java` ：

```java
/**
 * @author AruNi_Lu
 * @data 2022/7/8
 * 手机号码校验规则
 */

// 需要实现ConstraintValidator接口，泛型的第一个为注解的类型，第二个为校验值的类型
public class IsMobileValidator implements ConstraintValidator<IsMobile, String> {

    private boolean required = false;

    @Override
    public void initialize(IsMobile constraintAnnotation) {
        ConstraintValidator.super.initialize(constraintAnnotation);
    }

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if (required) {     // 如果是必填，则直接返回校验工具类中的校验方法
            return ValidatorUtil.isMobile(s);
        } else {
            // 如果是非必填，则要判断传入的值是空还是非空
            if (StringUtils.isEmpty(s)) {
                return true;
            } else {
                return ValidatorUtil.isMobile(s);
            }
        }
    }
}
```



**3、修改 LoginVo**：

在 `LoginVo.java` 中添加校验的注解，即可在前端传参过来时自动校验：

```java
@Data
public class LoginVo {
    @NotNull
    @IsMobile
    private String mobile;

    @NotNull
    @Length(min = 32)
    private String password;
}
```



**4、其他修改**：

`LoginController`：入参添加 `@Valid` 注解

```java
    /**
     * 登录功能
     * @param loginVo
     * @return
     */
    @RequestMapping("/doLogin")
    @ResponseBody
    public RespBean doLogin(@Valid LoginVo loginVo) {
        log.info("{}", loginVo);    // 查看前端传过来的参数
        return userService.login(loginVo);
    }
```

去掉 `UserServiceImpl` 中健壮性判断代码：

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public RespBean login(LoginVo loginVo) {
        String mobile = loginVo.getMobile();
        String pwd = loginVo.getPassword();

//        不用下面代码校验，使用 validator 校验
//        if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(pwd)) {
//            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
//        }
//        // 校验手机号
//        if (!ValidatorUtil.isMobile(mobile)) {
//            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
//        }

        // mobile就是id
        User user = userMapper.selectById(mobile);
        if (user == null) {
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        // 判断密码是否正确，前端传过来的密码已经加密过一次，只需要将用户的salt和pwd传进后端加密方法里，看得到的二次加密的密码是否和DB中一致
        if (!MD5Util.BackendPwdEncryption(pwd, user.getSalt()).equals(user.getPassword())) {
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        return RespBean.success();
    }
}
```

启动测试，可以发现当输入的手机号有问题时，控制台会打印出一个绑定异常 `BindException`，前端界面并未出现任何提示：

![image-20220708122422788](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220708122422788.png)

所以接下来就需要捕获异常，再给前端传相应的信息。



### 4.3 异常处理

系统中异常包括：编译时异常和运行时异常，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。

在开发中，不管是 dao 层、service 层还是 controller 层，都有可能抛出异常，在 SpringMVC 中，能将所有类型的异常处理从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。
SpringBoot 全局异常处理方式主要两种：

- `@ControllerAdvice` 和 `@ExceptionHandler` 注解
- `ErrorController` 类

区别：

- `@ControllerAdvice` 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。
- `ErrorController` 类 方式可以处理所有的异常，包括未进入控制器的错误，比如 404，401 等错误
- 如果应用中两者共同存在，则 `@ControllerAdvice` 方式处理控制器抛出的异常，`ErrorController` 类 方式处理未进入控制器的异常。
- `@ControllerAdvice` 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常
  信息，自由度更大。



#### 全局异常处理

新建 `exception` 包，创建全局异常类 `GlobalException.java` ，继承 `RuntimeException`：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GlobalException extends RuntimeException{

    private RespBeanEnum respBeanEnum;

}
```

创建全局异常处理类 `GlobalExceptionHandler.java`：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public RespBean ExceptionHandler(Exception e) {
        if (e instanceof GlobalException) {     // 当异常对象e是右边GlobalException异常时
            // 将异常对象e转为GlobalException，再抛出
            GlobalException ge = (GlobalException) e;
            return RespBean.error(ge.getRespBeanEnum());
        } else if (e instanceof BindException) {    // 当异常对象e是绑定异常时
            BindException ge = (BindException) e;
            RespBean respBean = RespBean.error(RespBeanEnum.BIND_ERROR);
            // 获取异常绑定结果中的第1个错误信息（Bind异常只有一个），
            respBean.setMessage("参数校验异常：" + ge.getBindingResult().getAllErrors().get(0).getDefaultMessage());
            return respBean;
        }
        // 其他异常
        return RespBean.error(RespBeanEnum.ERROR);
    }
    
}
```

> 修改之前的代码

在 `UserServiceImpl` 中将直接返回 `RespBean` 的代码改为直接抛 `GlobalException` 异常

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public RespBean login(LoginVo loginVo) {
        String mobile = loginVo.getMobile();
        String pwd = loginVo.getPassword();

//        不用下面代码校验，使用 validator 校验
//        if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(pwd)) {
//            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
//        }
//        // 校验手机号
//        if (!ValidatorUtil.isMobile(mobile)) {
//            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
//        }

        // mobile就是id
        User user = userMapper.selectById(mobile);
        if (user == null) {
            throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
        }
        // 判断密码是否正确，前端传过来的密码已经加密过一次，只需要将用户的salt和pwd传进后端加密方法里，看得到的二次加密的密码是否和DB中一致
        if (!MD5Util.BackendPwdEncryption(pwd, user.getSalt()).equals(user.getPassword())) {
            throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
        }
        return RespBean.success();
    }
}
```



运行测试：

![image-20220708130959627](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220708130959627.png)

### 4.4 分布式 Session

#### 完善登录功能

使用 cookie + session 记录用户信息，来判断用户的登录状态。



**1、准备工具类**

新建 `UUIDUtil.java`：

```java
public class UUIDUtil {
    public static String uuid() {
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

新建 `CookieUtil.java`：

```java
/**
 * @author AruNi_Lu
 * @data 2022/7/8
 * Cookie 工具类
 */
public final class CookieUtil {

    /**
     * 得到Cookie的值, 不编码
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName) {
        return getCookieValue(request, cookieName, false);
    }

    /**
     * 得到Cookie的值
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i < cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    if (isDecoder) {
                        retValue = URLDecoder.decode(cookieList[i].getValue(), "UTF-8");
                    } else {
                        retValue = cookieList[i].getValue();
                    }
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 得到Cookie的值
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i < cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue) {
        setCookie(request, response, cookieName, cookieValue, -1);
    }

    /**
     * 设置Cookie的值 在指定时间内生效,但不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage) {
        setCookie(request, response, cookieName, cookieValue, cookieMaxage, false);
    }

    /**
     * 设置Cookie的值 不设置生效时间,但编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, boolean isEncode) {
        setCookie(request, response, cookieName, cookieValue, -1, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage, boolean isEncode) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage, String encodeString) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);
    }

    /**
     * 删除Cookie带cookie域名
     */
    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response,
                                    String cookieName) {
        doSetCookie(request, response, cookieName, "", -1, false);
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
                                          String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {
        try {
            if (cookieValue == null) {
                cookieValue = "";
            } else if (isEncode) {
                cookieValue = URLEncoder.encode(cookieValue, "utf-8");
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage > 0)
                cookie.setMaxAge(cookieMaxage);
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!"localhost".equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath("/");
            response.addCookie(cookie);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
                                          String cookieName, String cookieValue, int cookieMaxage, String encodeString) {
        try {
            if (cookieValue == null) {
                cookieValue = "";
            } else {
                cookieValue = URLEncoder.encode(cookieValue, encodeString);
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage > 0) {
                cookie.setMaxAge(cookieMaxage);
            }
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!"localhost".equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath("/");
            response.addCookie(cookie);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 得到cookie的域名
     */
    private static final String getDomainName(HttpServletRequest request) {
        String domainName = null;
        // 通过request对象获取访问的url地址
        String serverName = request.getRequestURL().toString();
        if (serverName == null || serverName.equals("")) {
            domainName = "";
        } else {
            // 将url地下转换为小写
            serverName = serverName.toLowerCase();
            // 如果url地址是以http://开头  将http://截取
            if (serverName.startsWith("http://")) {
                serverName = serverName.substring(7);
            }
            int end = serverName.length();
            // 判断url地址是否包含"/"
            if (serverName.contains("/")) {
                //得到第一个"/"出现的位置
                end = serverName.indexOf("/");
            }

            // 截取
            serverName = serverName.substring(0, end);
            // 根据"."进行分割
            final String[] domains = serverName.split("\\.");
            int len = domains.length;
            if (len > 3) {
                // www.xxx.com.cn
                domainName = domains[len - 3] + "." + domains[len - 2] + "." + domains[len - 1];
            } else if (len <= 3 && len > 1) {
                // xxx.com or xxx.cn
                domainName = domains[len - 2] + "." + domains[len - 1];
            } else {
                domainName = serverName;
            }
        }

        if (domainName != null && domainName.indexOf(":") > 0) {
            String[] ary = domainName.split("\\:");
            domainName = ary[0];
        }
        return domainName;
    }
}
```



**2、添加业务代码**

`LoginController.java` 中添加 `HttpServlet` 参数，调用 `UserService` 时将次参数传入去，对应的 `IUserService` 也需要改：

```java
@Controller
@RequestMapping("/login")
@Slf4j
public class LoginController {

    @Autowired
    private IUserService userService;

    /**
     * 跳转到登录页面
     * @return
     */
    @RequestMapping("/toLogin")
    public String toLogin() {
        return "login";
    }

    /**
     * 登录功能
     * @param loginVo
     * @return
     */
    @RequestMapping("/doLogin")
    @ResponseBody
    public RespBean doLogin(@Valid LoginVo loginVo, HttpServletRequest request, HttpServletResponse response) {
        log.info("{}", loginVo);    // 查看前端传过来的参数
        return userService.login(loginVo, request, response);
    }

}
```



新建 `GoodsController.java`：

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {

    /**
     * 跳转到商品列表页面
     * @param session
     * @param model
     * @param cookie
     * @return
     */
    @RequestMapping("/toList")
    public String toList(HttpSession session, Model model, @CookieValue("userCookie") String cookie) {
        // 此处可用拦截器
        if (StringUtils.isEmpty(cookie)) {
            return "login";
        }
        User user = (User) session.getAttribute(cookie);    // 通过cookie对应的value拿到user
        if (user == null) {
            return "login";
        }
        model.addAttribute("user", user);   // 将user传给前端
        return "goodsList";
    }
}
```



#### 分布式 Session 问题

之前的代码在我们之后一台应用系统，所有操作都在一台 Tomcat 上，没有什么问题。当我们部署多台
系统，配合Nginx的时候会出现用户登录的问题

原因：
由于 Nginx 使用默认负载均衡策略（轮询），请求将会按照时间顺序逐一分发到后端应用上。也就是说刚开始我们在 Tomcat1 登录之后，用户信息放在 Tomcat1 的 Session 里。过了一会，请求又被 Nginx 分发到了 Tomcat2 上，这时 Tomcat2 上 Session 里还没有用户信息，于是又要登录。

解决方案：

- Session 复制
  - 优点：
    - 无需修改代码，只需要修改 Tomcat 配置
  - 缺点：
    - Session 同步传输占用内网带宽
    - 多台 Tomcat 同步性能指数级下降
    - Session 占用内存，无法有效水平扩展
- 前端存储
  - 优点：
    - 不占用服务端内存
  - 缺点：
    - 存在安全风险
    - 数据大小受 cookie 限制
    - 占用外网带宽
- Session 粘滞
  - 优点：
    - 无需修改代码
    - 服务端可以水平扩展
  - 缺点：
    - 增加新机器，会重新Hash，导致重新登录
    - 应用重启，需要重新登录
- 后端集中存储
  - 优点：
    - 安全
    - 容易水平扩展
  - 缺点：
    - 增加复杂度
    - 需要修改代码



#### Redis 安装

1、下载安装包！`redis-5.0.8.tar.gz`，程序一般放在`/opt`目录下

2、解压Redis的安装包

```Bash
[root@VM-16-12-centos opt]# ls
mellanox  redis-6.0.6.tar.gz  rh
[root@VM-16-12-centos opt]# tar -zxvf redis-6.0.6.tar.gz
# 解压......
```

解压完成后查看目录：

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/43396ee7e60f887c2d64d13cf9e0a1f4.png)

3、进入redis目录，可以看到redis的配置文件：

4、基本环境安装

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/ba5ecf5bd52416d66457c5a6726473a4.png)

```bash
# 先安装gcc
yum install gcc-c++
# 然后执行make
make
# 最后执行
make install
```

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/f3c39bf977b6b230ff0c84dfe7f3ab93.png)

注意：安装6.0以上版本需要升级gcc到5.3及以上，如下：升级到gcc 9.3：

 `yum -y install centos-release-scl`

 `yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils` 

`scl enable devtoolset-9 bash` 

需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。 如果要长期使用gcc 9.3的话：

 `echo "source /opt/rh/devtoolset-9/enable" >>/etc/profile` 

这样退出shell重新打开就是新版的gcc了

5、redis默认安装路径 `/usr/local/bin`

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/7cda151f3fd5218a797811d120616521.png)

6、将redis的配置文件复制到当前程序安装目录 `/usr/local/bin/自己的配置文件处`下，我们之后就用这个配置文件启动redis

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/68c2bef1f5cdf04b4d1652a17916a3b0.png)

7、redis默认不是后台启动的，需要修改配置文件：`vim redis.conf`后按`i`进入编辑，将`daemonize no`改为`yes`后按`esc`，再按`:`+`wq`保存退出

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/bf6af700e8940ecaade24413bc30c651.png)

8、通过指定的配置文件启动redis服务`redis-server run-config/redis.conf`

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/e995951883dc782b151472421b8a70ae.png)

9、使用`redis-cli`连接指定的端口号测试，Redis的默认端口6379：`redis-cli -p 6379`

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/a203a551f589307803094866a34c5a74.png)

10、新建一个会话，链接服务器；查看redis进程是否开启`ps -ef|grep redis`

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/1d3aeaf64c7a2140c264367d649b75a8.png)

11、关闭Redis服务 `shutdown`，退出`exit`

12、再次查看进程是否存在，可以看到redis-server和redis-cli都没有了

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/9a90206448ec6a8835190b908bfedb37.png)



#### Redis 实现分布式 Session

> 方式一：使用 SpringSession 实现

**1、添加依赖**

```xml
	<!--Spring data redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--commons-pool2 对象池依赖-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!--spring-session-->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```

**2、添加 redis 配置**

```yaml
  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: xxx.xxx.xxx.xxx
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
    password: 123456
    # lettuce 连接池配置
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接，默认8
        max-idle: 200
        #最小空闲连接，默认0
        min-idle: 5
```

**3、测试**

其他代码不用动，重新登录测试。会发现 session 已经存储在 Redis 上了。

![image-20220708203424047](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220708203424047.png)



> 方式二：将用户信息存入 Redis

将刚刚生成的 spring session 删除，将 spring session 依赖也删除，只保留 spring data redis 和 commons-pool2。redis 配置不需要改动。

**1、添加 redis 配置类**

新建 `config` 包，创建 `RedisConfig.java` 配置类：

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // key 序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // value 序列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        // hash 类型 key 序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        // hash 类型 value 序列化
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());

        // 注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
}
```

**2、修改之前的类**

`IUserService` 接口中添加 `getUserByCookie` 方法，从 redis 中根据 cookie 获取用户对象：

```java
public interface IUserService extends IService<User> {
    RespBean login(LoginVo loginVo, HttpServletRequest request, HttpServletResponse response);

    User getUserByCookie(String userCookie);
}
```

`UserServiceImpl` ，将用户 cookie 存入 redis 中，实现 `getUserByCookie` ：

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 登录业务
     */
    @Override
    public RespBean login(LoginVo loginVo, HttpServletRequest request, HttpServletResponse response) {
        String mobile = loginVo.getMobile();
        String pwd = loginVo.getPassword();

//        不用下面代码校验，使用 validator 校验
//        if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(pwd)) {
//            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
//        }
//        // 校验手机号
//        if (!ValidatorUtil.isMobile(mobile)) {
//            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
//        }

        // mobile就是id
        User user = userMapper.selectById(mobile);
        if (user == null) {
            throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
        }
        // 判断密码是否正确，前端传过来的密码已经加密过一次，只需要将用户的salt和pwd传进后端加密方法里，看得到的二次加密的密码是否和DB中一致
        if (!MD5Util.BackendPwdEncryption(pwd, user.getSalt()).equals(user.getPassword())) {
            throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
        }

        // 生成cookie
        String cookie = UUIDUtil.uuid();

        // 将cookie对应的用户存入session中
//        request.getSession().setAttribute(cookie, user);

        // 用户cookie不存在session中了，存入Redis中
        redisTemplate.opsForValue().set("user:" + cookie, user);

        // 将cookie保存，方便后续通过@CookieValue()注解获取
        CookieUtil.setCookie(request, response, "userCookie", cookie);

        return RespBean.success();
    }

    /**
     * 根据cookie获取用户对象
     */
    @Override
    public User getUserByCookie(String userCookie, HttpServletRequest request, HttpServletResponse response) {
        if (StringUtils.isEmpty(userCookie)) {
            return null;
        }
        // 从redis 中获取用户对象
        User user = (User) redisTemplate.opsForValue().get("user:" + userCookie);
        // 用户不为空，重新设置一下cookie，以防万一
        if (user != null) {
            CookieUtil.setCookie(request, response, "userCookie", userCookie);
        }
        return user;
    }
}
```

`GoodsController` 不通过 session 获取 user 对象了，通过 redis：

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {

    @Autowired
    private IUserService userService;

    /**
     * 跳转到商品列表页面
     */
    @RequestMapping("/toList")
    public String toList(HttpServletRequest request, HttpServletResponse response, Model model, @CookieValue("userCookie") String cookie) {
        if (StringUtils.isEmpty(cookie)) {
            return "login";
        }
        // User user = (User) session.getAttribute(cookie);    // 通过cookie对应的value拿到user

        // 不用HttpSession获取对象了，通过redis获取user对象
        User user = userService.getUserByCookie(cookie, request, response);
        if (user == null) {
            return "login";
        }
        model.addAttribute("user", user);   // 将user传给前端
        return "goodsList";
    }
}
```

**3、测试**

登录成功后，可以看到 redis 中有对应的 session，并且通过 Json 格式查看，可以看到 key 为 `user:` + `cookie`，value 为 `User` 对象 ：

![image-20220708211452773](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220708211452773.png)



#### 优化登录功能

每次进入商品列表页时，需要校验用户信息，进入商品详情页时，也需要校验。如果每次都在 controller 层判断就会显得代码很臃肿，所以需要统一处理校验的问题。

**1、添加配置类**

`WebConfig.java` web 配置类：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private UserArgumentResolve userArgumentResolve;

    /**
     *不过滤静态资源
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
    }

    /**
     * 通过自定义User参数实现类似拦截器的功能
     */
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(userArgumentResolve);
    }
}
```

`UserArgumentResolve.java` 自定义用户参数类，实现 `HandlerMethodArgumentResolver` 接口，类似拦截器，**在 controller 层入参之前就先做一层校验**：

```java
@Component
public class UserArgumentResolve implements HandlerMethodArgumentResolver {

    @Autowired
    private IUserService userService;

    /**
     * 条件判断，结果为true 才执行下面的 resolveArgument() 方法
     */
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        // 得到的参数类型是User类型就通过
        Class<?> clazz = parameter.getParameterType();
        return clazz == User.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        // 先获取HttpServletRequest，CookieUtil.getCookieValue() 需要
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);

        // 获取cookie
        String cookie = CookieUtil.getCookieValue(request, "userCookie");
        if (StringUtils.isEmpty(cookie)) {
            return null;
        }
        // 返回通过cookie获取的user对象，可以传到controller里面
        return userService.getUserByCookie(cookie, request, response);
    }
}
```



**2、修改业务代码**

`GoodsController.java` 直接注释掉原来有关判断用户是否登录的代码：

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {

    @Autowired
    private IUserService userService;

    /**
     * 跳转到商品列表页面
     * @param user 通过了自定义用户参数类HandlerMethodArgumentResolver后传过来的user
     */
    @RequestMapping("/toList")
    public String toList(Model model, User user) {
//        if (StringUtils.isEmpty(cookie)) {
//            return "login";
//        }
//        // User user = (User) session.getAttribute(cookie);    // 通过cookie对应的value拿到user
//
//        // 不用HttpSession获取对象了，通过redis获取user对象
//        User user = userService.getUserByCookie(cookie, request, response);
//        if (user == null) {
//            return "login";
//        }
        model.addAttribute("user", user);   // 将user传给前端
        return "goodsList";
    }
}
```

这样就实现了一个类似拦截器的功能，每次参数传到后端来的时候，都会先走 `WebConfig` 中的自定义参数类 `UserArgumentResolve`，只有符合条件的 User 才能走对应的 controller。



## 5. 秒杀功能

新建商品表、订单表、秒杀商品表、秒杀订单表。秒杀也要新建一个表是因为秒杀有时候会有不同的活动，而且秒杀的链接和商品平常卖的链接会不一样，如果只用一个表非常不好控制。

秒杀商品表会和商品表的 id 做关联，这样就只用在秒杀表上增加秒杀有关的属性即可。

商品表：

![image-20220710192731575](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710192731575.png)

订单表：

![image-20220710192840702](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710192840702.png)

秒杀商品表：

![image-20220710192925103](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710192925103.png)

秒杀订单表：

![image-20220710192951653](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710192951653.png)

建好表后，用逆向工程生成所需的所有类，拷贝到项目中。

### 5.1 商品列表页

`GoodsVo`，同时查询商品表和秒杀商品表的返回对象：

```java
/**
 * @author AruNi_Lu
 * @data 2022/7/10
 * 继承 Goods 类，可以获取商品的名称、图片等
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GoodsVo extends Goods {
    private BigDecimal seckillPrice;
    // 秒杀库存
    private Integer stockCount;
    private Date startDate;
    private Date endDate;
}
```

`GoodsController`：

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {

    @Autowired
    private IUserService userService;

    @Autowired
    private IGoodsService goodsService;

    /**
     * 跳转到商品列表页面
     * @param user 通过了自定义用户参数类HandlerMethodArgumentResolver后传过来的user
     */
    @RequestMapping("/toList")
    public String toList(Model model, User user) {
//        if (StringUtils.isEmpty(cookie)) {
//            return "login";
//        }
//        // User user = (User) session.getAttribute(cookie);    // 通过cookie对应的value拿到user
//
//        // 不用HttpSession获取对象了，通过redis获取user对象
//        User user = userService.getUserByCookie(cookie, request, response);
//        if (user == null) {
//            return "login";
//        }
        model.addAttribute("user", user);   // 将user传给前端
        model.addAttribute("goodsList", goodsService.findGoodsVo());	// 返回商品列表给前端
        return "goodsList";
    }
}
```

`GoodsMapper.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.run.seckill.mapper.GoodsMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.run.seckill.pojo.Goods">
        <id column="id" property="id" />
        <result column="goods_name" property="goodsName" />
        <result column="goods_title" property="goodsTitle" />
        <result column="goods_img" property="goodsImg" />
        <result column="goods_detail" property="goodsDetail" />
        <result column="goods_price" property="goodsPrice" />
        <result column="goods_stock" property="goodsStock" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, goods_name, goods_title, goods_img, goods_detail, goods_price, goods_stock
    </sql>

    <!-- 获取商品列表 -->
    <select id="findGoodsVo" resultType="com.run.seckill.vo.GoodsVo">
        SELECT
            g.goods_name,
            g.goods_title,
            g.goods_img,
            g.goods_detail,
            g.goods_price,
            g.goods_stock,
            sg.seckill_price,
            sg.stock_count,
            sg.start_date,
            sg.end_date
        FROM
            t_goods AS g
                LEFT JOIN t_seckill_goods AS sg ON g.id = sg.goods_id
    </select>

</mapper>
```

`goodsList.html`：

```html
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>商品列表</title>
    <!-- jquery -->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}"/>
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<div class="panel panel-default">
    <div class="panel-heading">秒杀商品列表</div>
    <table class="table" id="goodslist">
        <tr>
            <td>商品名称</td>
            <td>商品图片</td>
            <td>商品原价</td>
            <td>秒杀价</td>
            <td>库存数量</td>
            <td>详情</td>
        </tr>
        <tr th:each="goods, goodsStatus : ${goodsList}">
            <td th:text="${goods.goodsName}"></td>
            <td><img th:src="@{${goods.goodsImg}}" width="100" height="100"/></td>
            <td th:text="${goods.goodsPrice}"></td>
            <td th:text="${goods.seckillPrice}"></td>
            <td th:text="${goods.stockCount}"></td>
            <td><a th:href="'/goods/toDetail/' + ${goods.id}">详情</a></td>
        </tr>
    </table>
</div>
</body>
</html>
```



测试：

![image-20220710204227203](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710204227203.png)

### 5.2 商品详情页

`GoodsController`：

```java
@RequestMapping("/toDetail/{goodsId}")
    public String toDetail(@PathVariable Long goodsId, Model model, User user) {
        model.addAttribute("user", user);
        model.addAttribute("goods", goodsService.findGoodsById(goodsId));
        return "goodsDetail";
    }
```

`GoodsMapper.xml`：

```xml
    <!-- 查看商品详情-->
    <select id="findGoodsById" resultType="com.run.seckill.vo.GoodsVo">
        SELECT
            g.id,
            g.goods_name,
            g.goods_title,
            g.goods_img,
            g.goods_detail,
            g.goods_price,
            g.goods_stock,
            sg.seckill_price,
            sg.stock_count,
            sg.start_date,
            sg.end_date
        FROM
            t_goods AS g
                LEFT JOIN t_seckill_goods AS sg ON g.id = sg.goods_id
        where g.id = #{goodsId}
    </select>
```

`goodsDetail.html`，秒杀时间、倒计时、秒杀按钮暂时不写，后面详细理解：

```html
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>商品详情</title>
    <!-- jquery -->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}"/>
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<div class="panel panel-default">
    <div class="panel-heading">秒杀商品详情</div>
    <div class="panel-body">
        <span th:if="${user eq null}"> 您还没有登录，请登陆后再操作<br/></span>
        <span>没有收货地址的提示。。。</span>
    </div>
    <table class="table" id="goods">
        <tr>
            <td>商品名称</td>
            <td colspan="3" th:text="${goods.goodsName}"></td>
        </tr>
        <tr>
            <td>商品图片</td>
            <td colspan="3"><img th:src="@{${goods.goodsImg}}" width="200" height="200"/></td>
        </tr>
        <tr>
            <td>秒杀开始时间</td>

        </tr>
        <tr>
            <td>商品原价</td>
            <td colspan="3" th:text="${goods.goodsPrice}"></td>
        </tr>
        <tr>
            <td>秒杀价</td>
            <td colspan="3" th:text="${goods.seckillPrice}"></td>
        </tr>
        <tr>
            <td>库存数量</td>
            <td colspan="3" th:text="${goods.stockCount}"></td>
        </tr>
    </table>
</div>
</body>
<script>
    
</script>
</html>
```



测试：

![image-20220710211454662](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710211454662.png)



> 实现秒杀时间、倒计时、秒杀按钮

秒杀时间显示：

因为 `GoodsVo` 中是有米哦啊啥的开始时间和结束时间的，所以直接在 `goodsDetail.html` 中获取：

```html
	<tr>
            <td>秒杀开始时间</td>
            <!-- 使用 common.js 中的 dates.format 格式化-->
            <td th:text="${#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')}"></td>
        </tr>
```

测试：

![image-20220710213121536](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710213121536.png)

秒杀状态：

`GoodsController`：

```java
    @RequestMapping("/toDetail/{goodsId}")
    public String toDetail(@PathVariable Long goodsId, Model model, User user) {
        model.addAttribute("user", user);
        GoodsVo goodsVo = goodsService.findGoodsById(goodsId);
        Date startDate = goodsVo.getStartDate();
        Date endDate = goodsVo.getEndDate();
        Date nowDate = new Date();
        int secKillStatus = 0;  // 秒杀状态，0-未开始；1-进行中；2-已结束
        int remainSeconds = 0;
        if (nowDate.before(startDate)) {    // 秒杀未开始
            remainSeconds = (int) ((startDate.getTime() - nowDate.getTime()) / 1000);
        } else if (nowDate.after(endDate)) {    // 秒杀已结束
            secKillStatus = 2;
            remainSeconds = -1;
        } else {    // 秒杀进行中
            secKillStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("remainSeconds", remainSeconds);
        model.addAttribute("secKillStatus", secKillStatus);
        model.addAttribute("goods", goodsVo);
        return "goodsDetail";
    }
```

`goodsDetail.html`：

```html
	<tr>
            <td>秒杀开始时间</td>
            <!-- 使用 common.js 中的 dates.format 格式化-->
            <td th:text="${#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')}"></td>
            <td id="seckillTip">
                <span th:if="${secKillStatus eq 0}">秒杀倒计时：
                    <span th:text="${remainSeconds}"></span>秒
                </span>
                <span th:if="${seckillStatus eq 1}">秒杀进行中</span>
                <span th:if="${secKillStatus eq 2}">秒杀已结束</span>
            </td>
        </tr>
```

测试发现，倒计时是静态的，只有刷新才会更新倒计时：

![image-20220710222122202](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710222122202.png)

要想动态的实现倒计时，需要使用到前端的定时器。

`goodsDetail.html`：

```html
	<tr>
            <td>秒杀开始时间</td>
            <!-- 使用 common.js 中的 dates.format 格式化-->
            <td th:text="${#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')}"></td>
            <td id="seckillTip">
                <!-- 隐藏域，为了防止在秒杀进行中/已结束的状态下，countDown()方法获取不到remainSeconds的值-->
                <input type="hidden" id="remainSeconds" th:value="${remainSeconds}">
                <span th:if="${secKillStatus eq 0}">秒杀倒计时：
                    <span id="countDown" th:text="${remainSeconds}"></span>秒
                </span>
                <span th:if="${seckillStatus eq 1}">秒杀进行中</span>
                <span th:if="${secKillStatus eq 2}">秒杀已结束</span>
            </td>
            <td>
                <form id="secKillForm" method="post" action="/seckill/doSeckill">
                    <input type="hidden" name="goodsId" th:value="${goods.id}">
                    <button id="buyButton" class="btn btn-primary btn-block" type="submit">立即秒杀</button>
                </form>
            </td>
        </tr>


<script>
    $(function (){
        countDown();
    });

    // 倒计时定时器，使倒计时每隔1秒减1秒
    function countDown() {
        var remainSeconds = $("#remainSeconds").val();
        var timeout;
        if (remainSeconds > 0) {        // 秒杀未开始
            timeout = setTimeout(function (){
                // 将秒杀按钮置为不可用
                $("#buyButton").attr("disabled", true);
                // 根据id将页面的倒计时-1
                $("#countDown").text(remainSeconds - 1);
                // 根据id将隐藏域中的倒计时-1
                $("#remainSeconds").val(remainSeconds - 1);
                countDown();
            }, 1000);   // 每1秒执行一次
        } else if (remainSeconds == 0) {    // 秒杀进行中，若timeout还存在则清除
            $("#buyButton").attr("disabled", false);
            if (timeout) {
                clearTimeout(timeout);
            }
            $("#seckillTip").html("秒杀进行中")
        } else {
            $("#buyButton").attr("disabled", true);
            $("#seckillTip").html("秒杀已结束")
        }
    }
</script>
```

测试：

还未开始秒杀时，按钮不可用：

![image-20220710231122161](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710231122161.png)

开始秒杀时：

![image-20220710231323048](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220710231323048.png)



### 5.3 秒杀功能实现

`SecKillController`：

```java
@Controller
@RequestMapping("/seckill")
public class SecKillController {

    @Autowired
    private IGoodsService goodsService;

    @Autowired
    private ISeckillOrderService seckillOrderService;

    @Autowired
    private IOrderService orderService;

    @RequestMapping("/doSeckill")
    public String doSecKill(Model model, User user, Long goodsId) {
        if (user == null) return "login";
        model.addAttribute("user", user);
        GoodsVo goodsVo = goodsService.findGoodsById(goodsId);
        // 判断秒杀库存
        if (goodsVo.getStockCount() < 1) {
            model.addAttribute("error", RespBeanEnumVo.EMPTY_STOCK.getMessage());
            return "secKillFail";
        }

        // 判断是否重复抢购
        SeckillOrder seckillOrder = seckillOrderService.findSeckillOrderByUserIdAndGoodsId(user.getId(), goodsId);
        if (seckillOrder != null) {
            model.addAttribute("error", RespBeanEnumVo.REPEAT_BUY.getMessage());
            return "secKillFail";
        }

        // 秒杀
        Order order = orderService.seckill(user, goodsVo);
        model.addAttribute("order", order);
        model.addAttribute("goods", goodsVo);
        return "orderDetail";

    }
}
```

`SeckillOrderServiceImpl`：

```java
@Service
public class SeckillOrderServiceImpl extends ServiceImpl<SeckillOrderMapper, SeckillOrder> implements ISeckillOrderService {

    @Autowired
    private SeckillOrderMapper seckillOrderMapper;

    @Override
    public SeckillOrder findSeckillOrderByUserIdAndGoodsId(Long id, Long goodsId) {
        return seckillOrderMapper.selectOne(new QueryWrapper<SeckillOrder>().eq("user_id", id).eq("goods_id", goodsId));
    }
}
```

`OrderServiceImpl`：

```java
@Service
public class OrderServiceImpl extends ServiceImpl<OrderMapper, Order> implements IOrderService {

    @Autowired
    private ISeckillGoodsService seckillGoodsService;

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private ISeckillOrderService seckillOrderService;

    @Override
    public Order seckill(User user, GoodsVo goodsVo) {
        // 秒杀商品表库存减1
        SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>().eq("goods_id", goodsVo.getId()));
        seckillGoods.setStockCount(seckillGoods.getStockCount() - 1);
        seckillGoodsService.updateById(seckillGoods);

        // 生成订单
        Order order = new Order();
        order.setUserId((user.getId()));
        order.setGoodsId(goodsVo.getId());
        order.setDeliveryAddrId(0L);
        order.setGoodsName(goodsVo.getGoodsName());
        order.setGoodsCount(1);
        order.setGoodsPrice(seckillGoods.getSeckillPrice());
        order.setOrderChannel(1);
        order.setStatus(0);
        order.setCreateDate(new Date());
        orderMapper.insert(order);

        //生成秒杀订单
        SeckillOrder seckillOrder = new SeckillOrder();
        seckillOrder.setOrderId(order.getId());
        seckillOrder.setUserId(user.getId());
        seckillOrder.setGoodsId(goodsVo.getId());
        seckillOrderService.save(seckillOrder);
        return order;
    }
}
```

`orderDetail.html`：

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>订单详情</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!-- jquery -->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}" />
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<div class="panel panel-default">
    <div class="panel-heading">秒杀订单详情</div>
    <table class="table" id="order">
        <tr>
            <td>商品名称</td>
            <td th:text="${goods.goodsName}" colspan="3"></td>
        </tr>
        <tr>
            <td>商品图片</td>
            <td colspan="2"><img th:src="@{${goods.goodsImg}}" width="200" height="200" /></td>
        </tr>
        <tr>
            <td>订单价格</td>
            <td colspan="2" th:text="${order.goodsPrice}"></td>
        </tr>
        <tr>
            <td>下单时间</td>
            <td th:text="${#dates.format(order.createDate, 'yyyy-MM-dd HH:mm:ss')}" colspan="2"></td>
        </tr>
        <tr>
            <td>订单状态</td>
            <td >
                <span th:if="${order.status eq 0}">未支付</span>
                <span th:if="${order.status eq 1}">待发货</span>
                <span th:if="${order.status eq 2}">已发货</span>
                <span th:if="${order.status eq 3}">已收货</span>
                <span th:if="${order.status eq 4}">已退款</span>
                <span th:if="${order.status eq 5}">已完成</span>
            </td>
            <td>
                <button class="btn btn-primary btn-block" type="submit" id="payButton">立即支付</button>
            </td>
        </tr>
        <tr>
            <td>收货人</td>
            <td colspan="2">XXX  18012345678</td>
        </tr>
        <tr>
            <td>收货地址</td>
            <td colspan="2">上海市浦东区世纪大道</td>
        </tr>
    </table>
</div>

</body>
</html>
```



## 6. 系统压测

### 6.1 JMeter

官网：https://jmeter.apache.org/

下载解压后直接在 bin 目录里双击 `jmeter.bat` 即可启动。

修改 `jmeter.properties` 配置文件：

```properties
#Preferred GUI language. Comment out to use the JVM default locale's language.
#language=en
language=zh_CN

# The encoding to be used if none is provided (default ISO-8859-1)
#sampleresult.default.encoding=ISO-8859-1
sampleresult.default.encoding=UTF-8
```



> 简单使用

我们先使用JMeter测试一下跳转商品列表页的接口。

1、首先创建线程组，步骤：添加--> 线程(用户) --> 线程组

![image-20220713135842499](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220713135842499.png)

Ramp-up 指在几秒之内启动指定线程数，0 代表自动。

2、创建HTTP请求默认值，步骤：添加--> 配置元件 --> HTTP请求默认值

![image-20220713140139276](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220713140139276.png)

3、添加测试接口，步骤：添加 --> 取样器 --> HTTP请求

![image-20220713140248013](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220713140248013.png)

4、查看输出结果，步骤：添加 --> 监听器 --> 聚合报告/图形结果/用表格察看结果

![image-20220713141407302](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220713141407302.png)





### 6.2 Linux 安装 MySQL

> 下载

1、先下载 wget

```shell
[root@localhost ~]# yum -y install wget
```

2、下载并安装 MySQL 官方的 Yum Repository

```shell
[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
```

3、使用上面的命令就直接下载了安装用的 Yum Repository，然后就可以直接 yum 安装了

```shell
[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm
```

4、之后就开始安装 MySQL 服务器

```shell
[root@localhost ~]# yum -y install mysql-community-server
```

若安装失败，原因是 MySQL 的GPG升级了，需要重新获取，使用以下命令即可

```shell
[root@localhost ~]# rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
```

至此 MySQL 就安装完成了，然后是对 MySQL 的一些设置。



> 启动

首先启动 MySQL

```shell
[root@localhost ~]# systemctl start  mysqld.service
```

查看 MySQL 运行状态，运行状态如图：

```shell
[root@localhost ~]# systemctl status mysqld.service
```

![image-20220714235554511](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220714235554511.png)

此时 MySQL 已经开始正常运行，不过要想进入 MySQL 还得先找出此时 root 用户的密码，通过如下命令可以在日志文件中找出密码：

```shell
[root@localhost ~]# grep "password" /var/log/mysqld.log
```

![image-20220714235550640](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220714235550640.png)

如下命令进入数据库：

```shell
[root@localhost ~]# mysql -uroot -p
```

输入初始密码（是上面图片最后面的 no;e!5>>alfg），此时不能做任何事情，因为 MySQL 默认必须修改密码之后才能操作数据库：

```shell
mysql> alter user 'root'@'localhost' identified by 'new password';
```

其中 ‘new password’ 替换成你要设置的密码，注意：密码设置必须要大写 + 小写 + 字母 + 数字 + 特殊符号，不然不能配置成功。



> 开启远程访问

执行以下命令开启远程访问限制（注意：下面命令开启的IP是 192.168.0.1，如要开启所有的，用%代替IP，）：

```shell
grant all privileges on *.* to 'root'@'192.168.0.1' identified by 'your password' with grant option;
```

![image-20220714235518251](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220714235518251.png)

然后再输入下面两行命令

```shell
mysql> flush privileges; 
mysql> exit
```

此时就可以用 Navicat 在本地连接了。



> 建表

将本地的数据库表转储到 Linux 的数据库中。

![image-20220715000001277](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220715000001277.png)



在 `application.yaml` 配置文件中，MySQL 的 ip地址、用户名、密码等改成 Linux 的 MySQL 的：

![image-20220715000442077](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220715000442077.png)

将项目打包：

![image-20220715001711118](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220715001711118.png)

将打包好的 jar 包和 Jmeter 传到 Linux：

![image-20220715002611244](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220715002611244.png)

服务器运行 jar 包，测试是否正常运行：

```shell
[root@VM-16-12-centos seckill]# java -jar seckill-0.0.1-SNAPSHOT.jar 
```

![image-20220715004605706](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220715004605706.png)

运行成功，接下来就可以在 Linux 中使用 Jmeter 进行压测。



## 7. 页面优化

### 7.1 缓存

#### 页面缓存

`GoodsController.java`：

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {

    @Autowired
    private IUserService userService;

    @Autowired
    private IGoodsService goodsService;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private ThymeleafViewResolver thymeleafViewResolver;

    /**
     * 跳转到商品列表页面
     * @param user 通过了自定义用户参数类HandlerMethodArgumentResolver后传过来的user
     */
    // 不返回前端路径了，直接返回一个html页面和对应的数据对象
    @RequestMapping(value = "/toList", produces = "text/html;charset=utf-8")
    @ResponseBody
//    @RequestMapping("/toList")
    public String toList(Model model, User user, HttpServletRequest request, HttpServletResponse response) {
        // 从redis中获取页面，如果不为空，直接返回页面
        ValueOperations valueOperations = redisTemplate.opsForValue();
        String html = (String) valueOperations.get("goodList");
        if (!StringUtils.isEmpty(html)) {
            return html;
        }

        model.addAttribute("user", user);   // 将user传给前端
        // 返回商品列表给前端
        model.addAttribute("goodsList", goodsService.findGoodsVo());
//        return "goodsList";

        // redis中页面为空，用Thymeleaf手动渲染，再存入redis
        WebContext webContext = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());
        html = thymeleafViewResolver.getTemplateEngine().process("goodsList", webContext);
        if (!StringUtils.isEmpty(html)) {
            valueOperations.set("goodsList", html, 60, TimeUnit.SECONDS);
        }
        return html;
    }

    @RequestMapping(value = "/toDetail/{goodsId}", produces = "text/html;charset=utf-8")
    @ResponseBody
//    @RequestMapping("/toDetail/{goodsId}")
    public String toDetail(@PathVariable Long goodsId, Model model, User user, HttpServletRequest request, HttpServletResponse response) {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // Redis中获取页面，如果不为空，直接返回页面
        String html = (String) valueOperations.get("goodsDetail:" + goodsId);
        if (!StringUtils.isEmpty(html)) {
            return html;
        }

        model.addAttribute("user", user);
        GoodsVo goodsVo = goodsService.findGoodsById(goodsId);
        Date startDate = goodsVo.getStartDate();
        Date endDate = goodsVo.getEndDate();
        Date nowDate = new Date();
        int secKillStatus = 0;  // 秒杀状态，0-未开始；1-进行中；2-已结束
        int remainSeconds = 0;
        if (nowDate.before(startDate)) {    // 秒杀未开始
            remainSeconds = (int) ((startDate.getTime() - nowDate.getTime()) / 1000);
        } else if (nowDate.after(endDate)) {    // 秒杀已结束
            secKillStatus = 2;
            remainSeconds = -1;
        } else {    // 秒杀进行中
            secKillStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("remainSeconds", remainSeconds);
        model.addAttribute("secKillStatus", secKillStatus);
        model.addAttribute("goods", goodsVo);
//        return "goodsDetail";

        // 如果为空，手动渲染，存入Redis并返回
        WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());
        html = thymeleafViewResolver.getTemplateEngine().process("goodsDetail",
                context);
        if (!StringUtils.isEmpty(html)) {
            valueOperations.set("goodsDetail:" + goodsId, html, 60,
                    TimeUnit.SECONDS);
        }
        return html;
    }
```

测试发现 html 页面缓存到了 redis 中：

![image-20220719220055089](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220719220055089.png)

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/Snipaste_2022-07-19_22-00-59.png)



#### 对象缓存

之前在做分布式 session 的时候，对象是存储在 redis 中，也是从 redis 中获取对象的：

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 登录业务
     */
    @Override
    public RespBeanVo login(LoginParam loginParam, HttpServletRequest request, HttpServletResponse response) {
        String mobile = loginParam.getMobile();
        String pwd = loginParam.getPassword();

//        不用下面代码校验，使用 validator 校验
//        if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(pwd)) {
//            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
//        }
//        // 校验手机号
//        if (!ValidatorUtil.isMobile(mobile)) {
//            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
//        }

        // mobile就是id
        User user = userMapper.selectById(mobile);
        if (user == null) {
            throw new GlobalException(RespBeanEnumVo.LOGIN_ERROR);
        }
        // 判断密码是否正确，前端传过来的密码已经加密过一次，只需要将用户的salt和pwd传进后端加密方法里，看得到的二次加密的密码是否和DB中一致
        if (!MD5Util.BackendPwdEncryption(pwd, user.getSalt()).equals(user.getPassword())) {
            throw new GlobalException(RespBeanEnumVo.LOGIN_ERROR);
        }

        // 生成cookie
        String cookie = UUIDUtil.uuid();

        // 将cookie对应的用户存入session中
//        request.getSession().setAttribute(cookie, user);

        // 用户cookie不存在session中了，存入Redis中
        redisTemplate.opsForValue().set("user:" + cookie, user);

        // 将cookie保存，方便后续通过@CookieValue()注解获取
        CookieUtil.setCookie(request, response, "userCookie", cookie);

        return RespBeanVo.success();
    }

    /**
     * 根据cookie获取用户对象
     */
    @Override
    public User getUserByCookie(String userCookie, HttpServletRequest request, HttpServletResponse response) {
        if (StringUtils.isEmpty(userCookie)) {
            return null;
        }
        // 从redis 中获取用户对象
        User user = (User) redisTemplate.opsForValue().get("user:" + userCookie);
        // 用户不为空，重新设置一下cookie，以防万一
        if (user != null) {
            CookieUtil.setCookie(request, response, "userCookie", userCookie);
        }
        return user;
    }
}
```

这样看似好像没什么问题，对象也做了缓存。但是当时并没有设置失效时间，如果用户信息一旦更改，那么从 redis 中获取的对象就是错误的。

这时候就需要在修改个人信息时删除 redis 中缓存的信息，下面在 `UserServiceImpl.java` 中添加一个修改密码的方法。

`UserServiceImpl.java`：

```java
    /**
     * 修改密码
     */
    @Override
    public RespBeanVo updatePassword(String userCookie, String password, HttpServletRequest request, HttpServletResponse response) {
        User user = getUserByCookie(userCookie, request, response);
        if (user == null) {
            throw new GlobalException(RespBeanEnumVo.MOBILE_NOT_EXIST);
        }
        user.setPassword(MD5Util.inputPwdToDBPwd(password, user.getSalt()));
        int result = userMapper.updateById(user);
        if (result == 1) {
            // 删除 redis 缓存对象
            redisTemplate.delete("user" + userCookie);
            return RespBeanVo.success();
        }
        return RespBeanVo.error(RespBeanEnumVo.PASSWORD_UPDATE_FAIL);
    }
```

`RespBeanEnumVo.java`：

```java
    // 手机号码不存在
    MOBILE_NOT_EXIST(500213, "手机号码不存在"),

    // 密码更新失败
    PASSWORD_UPDATE_FAIL(500214, "密码更新失败"),
```



### 7.2 页面静态化

之前设置了页面的缓存，传输给前端的时候，传输了整个 html 页面，所以需要消耗的时间很大的。

可以将一些静态的页面，不会更变的页面固定，这样就只用传输动态的数据即可。

下面不使用前端的框架去实现页面静态化，因为当前这个项目并没有前后端分离。所以直接使用 Ajax 来模拟一下页面静态化。



### 7.3 解决库存超卖

在秒杀时，我们在 `SecKillController` 中做了对库存的判断，大于0才秒杀成功。但是在并发的情况下，只做这一个判断是不够的，会出现并发问题—库存超卖。

同理，在判断同一用户是否重复抢购时，只查询了 seckillOrder 表中是否有该订单记录，在并发的情况下也是会出现一样的问题的。

```java
    @RequestMapping("/doSeckill")
    public String doSecKill(Model model, User user, Long goodsId) {
        if (user == null) return "login";
        model.addAttribute("user", user);
        GoodsVo goodsVo = goodsService.findGoodsById(goodsId);
        // 判断秒杀库存
        if (goodsVo.getStockCount() < 1) {
            model.addAttribute("error", RespBeanEnumVo.EMPTY_STOCK.getMessage());
            return "secKillFail";
        }

        // 判断是否重复抢购
        SeckillOrder seckillOrder = seckillOrderService.findSeckillOrderByUserIdAndGoodsId(user.getId(), goodsId);
        if (seckillOrder != null) {
            model.addAttribute("error", RespBeanEnumVo.REPEAT_BUY.getMessage());
            return "secKillFail";
        }

        // 秒杀
        Order order = orderService.seckill(user, goodsVo);
        model.addAttribute("order", order);
        model.addAttribute("goods", goodsVo);
        return "orderDetail";

    }
```



所以在秒杀商品减库存的时候，需要做一个判断。

`OrderServiceImpl.java`：

```java
@Service
public class OrderServiceImpl extends ServiceImpl<OrderMapper, Order> implements IOrderService {

    @Autowired
    private ISeckillGoodsService seckillGoodsService;

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private ISeckillOrderService seckillOrderService;

    @Override
    public Order seckill(User user, GoodsVo goodsVo) {
        // 秒杀商品表库存减1
        SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>().eq("goods_id", goodsVo.getId()));
        seckillGoods.setStockCount(seckillGoods.getStockCount() - 1);
        // 在更新库存时判断库存数量必须大于0
        seckillGoodsService.update(new UpdateWrapper<SeckillGoods>().set("stock_count", seckillGoods.getStockCount()).eq("id", seckillGoods.getId()).gt("stock_count", 0));
        //        seckillGoodsService.updateById(seckillGoods);

        // 生成订单
        Order order = new Order();
        order.setUserId((user.getId()));
        order.setGoodsId(goodsVo.getId());
        order.setDeliveryAddrId(0L);
        order.setGoodsName(goodsVo.getGoodsName());
        order.setGoodsCount(1);
        order.setGoodsPrice(seckillGoods.getSeckillPrice());
        order.setOrderChannel(1);
        order.setStatus(0);
        order.setCreateDate(new Date());
        orderMapper.insert(order);

        //生成秒杀订单
        SeckillOrder seckillOrder = new SeckillOrder();
        seckillOrder.setOrderId(order.getId());
        seckillOrder.setUserId(user.getId());
        seckillOrder.setGoodsId(goodsVo.getId());
        seckillOrderService.save(seckillOrder);
        return order;
    }
}
```



解决重复抢购问题，可以使用数据库唯一索引来避免，生成订单时，将用户 id 和 商品 id 建立一个唯一索引，这样下次同一用户秒杀同一商品时就会被索引拦截：

![image-20220720144732432](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/image-20220720144732432.png)



## 8. 接口优化

### 8.1 Redis 操作库存

目的：减少数据库的访问。

思路：

1. 系统初始化，把商品库存数量加载到 Redis
2. 收到请求，Redis 预减库存。库存不足，直接返回。否则进入第三步
3. 请求入队，立即返回排队中
4. 请求出队，生成订单，减少库存
5. 客户端轮询，是否秒杀成功























