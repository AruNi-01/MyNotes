

::: info 前言

JVM 的 **自动内存管理机制** 帮助了我们很友好的使用内存，写 Java 代码时，不用为 new 出来的对象进行释放，JVM 会在合适的时机帮我们进行 **垃圾回收**。

但我们还是有必要去了解一下 Java 的内存区域是怎样的，JVM 是怎样使用内存的，这样在出现内存相关的问题时，比如内存泄漏、内存溢出，才有能力去排查。

本章先来了解 Java 的 **运行时数据区域** 是如何划分的，每个区域分别有什么作用，保存什么数据？

:::

## 1. 运行时数据区域有哪些？

JVM 在执行程序时，会将内存划分为几个不同的数据区域，如下所示：

![image-20230627230024084](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306272300232.png)

- **程序计数器**：一块比较小的空间，与 OS 的 PC 类似，**JVM 的解释器（在执行引擎中）就是通过改变这个计数器的值来取得下一条字节码指令**；

  > 在多线程场景下，**为了保证线程切换后能恢复到原来的执行位置，因此程序计数器是线程隔离的**，即每个线程都有一份。

- **Java 栈**：Java 方法执行时都需要创建一个 **栈帧**，用于存储 **局部变量表（比如一些基本数据类型、对象的引用）、方法出口等信息**。一个方法从调用到退出的过程，就对应 **一个栈帧在 Java 栈中从入栈到出栈的过程**；

  > 由于 **每个方法执行时存储的信息都不同**，所以 **Java 栈也是线程私有的**。

- **本地方法栈**：和 Java 栈类似，不过是用来执行 **本地（Native）方法** 的；

- **堆**：一块比较大且是所有 **线程共享** 的内存空间，用于 **保存对象实例**，Java 中几乎所有的对象实例都在这里面（说 “几乎” 是因为逃逸分析技术的存在），这也是 **GC 所管理的区域**；

- **方法区**：与堆一样，也是 **线程共享** 的一块内存，但它主要存储 **已被加载的类型信息、常量、静态变量** 等。

  > 为了降低内存溢出的风险，JDK 1.8 中使用了元空间来代替方法区的实现。

## 2. 程序计数器





















