## 中间件

> 什么是中间件

中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。

具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上。



> 中间件技术及架构

![image-20220703224843672](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703224843672.png)

单体架构：

![image-20220703224953791](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703224953791.png)

在企业开发当中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个工程中，如果其中的一个模块升级或者迭代发生一个很小的变动都会重新编译和重新部署项目。

单体架构存在的问题：

1. 耦合度太高
2. 不易维护
3. 服务器的成本高
4. 以及升级架构的复杂度也会增大

这样就有后续的分布式架构系统。如下：

![image-20220703225022254](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703225022254.png)

分布式系统：通俗一点，就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成。

和单体架构不同的是，单体架构是一个请求发起 jvm调度线程（确切的是 tomcat线程池）分配线程 Thread来处理请求直到释放，而分布式系统是：一个请求时由多个系统共同来协同完成，jvm和环境都可能是独立。

**存在问题：**

1. 学习成本高，技术栈过多
2. 运维成本和服务器成本增高
3. 人员的成本也会增高
4. 项目的负载度也会上升
5. 面临的错误和容错性也会成倍增加
6. 占用的服务器端口和通讯的选择的成本高
7. 安全性的考虑和因素逼迫可能选择 RMI/MQ相关的服务器端通讯

**好处：**

1. 服务系统的独立，占用的服务器资源减少和占用的硬件成本减少

   确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费

2. 系统的独立维护和部署，耦合度降低，可插拔性

3. 系统的架构和技术栈的选择可以变的灵活（而不是单纯地选择 java）

4. 弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态



## 消息队列

### 1. 什么是MQ

MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message  而已，还是一种跨进程的通信机制，用于上下游传递消息。

在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦+物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。

### 2. 为什么要用MQ

> 流量消峰

举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。

但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。

使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。

![image-20220703230516899](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703230516899.png)



> 应用解耦

以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果**耦合**调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。

当转变成基于 **消息队列** 的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，用户感受不到物流系统的故障，提升系统的可用性。

![image-20220703230815539](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703230815539.png)



> 异步处理

有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。

以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。

使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ  会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用  做这些操作。A 服务还能及时的得到异步处理成功的消息。

![image-20220703230918067](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703230918067.png)



### 3. MQ的分类

> ActiveMQ

**优点**：

- 单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性高，丢失数据概率很低。

**缺点**：

- 官方社区 Apache 现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。



> Kafka

大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为**大数据而生**的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。

**优点**：

- 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是**吞吐量高**；
- 时效性 ms 级，可用性非常高；
- Kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用；
- 消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；
- 有优秀的第三方Kafka Web 管理界面  Kafka-Manager；
- 在日志领域比较成熟，被多家公司和多个开源项目使用；
- 功能较为简单，主要支持简单的 MQ  功能，在大数据领域的实时计算以及日志采集被大规模使用。

**缺点**：

- Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高(CPU)现象，队列越多，Load 越高，发送消息响应时间变长；
- 使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试，意味着消息可能会丢失；
- 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；
- **社区更新较慢**。



> RocketMQ

RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。

**优点**：

- **单机吞吐量十万级**，可用性非常高，分布式架构，**消息可以做到 0 丢失**；
- MQ 功能较为完善，还是分布式的，扩展性好；
- **支持 10 亿级别的消息堆积**，不会因为堆积导致性能下降；
- 源码是 Java，可以自己阅读源码，定制自己公司的 MQ。

**缺点**：

- **支持的客户端语言不多**，目前是 Java 及 C++，其中 C++不成熟；
- 社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。



> RabbitMQ

2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，**是当前最主流的消息中间件之一。**

**优点**：

- 由于 erlang 语言的高并发特性，性能较好；
- 吞吐量到万级，MQ 功能比较完备、健壮、稳定、易用、跨平台、支持多种语言  如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，文档齐全；
- 开源提供的管理界面非常棒，用起来很好用，社区活跃度高，更新频率相当高。

**缺点**：

- 商业版需要收费，学习成本较高

### 4. MQ的选择

> Kafka

Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。



> RocketMQ

天生为**金融互联网**领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。



> RabbitMQ

结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的**数据量没有那么大**，中小型公司优先选择功能比较完备的 RabbitMQ。



## RabbitMQ 概念

RabbitMQ 是一个消息中间件：它接受并转发消息。

你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。

RabbitMQ 与快递站的主要区别在于，它不处理快件，而是接收、存储和转发消息数据。

![image-20220703232606036](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703232606036.png)



### 1. 四大核心概念

> 生产者

产生数据发送消息的程序是生产者



> 交换机

交换机是 RabbitMQ 非常重要的一个部件，一方面它**接收来自生产者的消息**，另一方面它**将消息推送到队列中**。

交换机必须**确切知道如何处理它接收到的消息**，是将这些消息推送到**特定队列**还是推送到**多个队列**，亦或者是把消息丢弃，这个得有交换机类型决定。



> 队列

队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。

队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多**生产者**可以**将消息发送到一个队列**，许多**消费者**可以尝试**从一个队列接收数据**。这就是使用队列的方式。



> 消费者

消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者、消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。

![image-20220703234646987](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220703234646987.png)

### 2. 核心部分

> 六大模式

1. 简单模式
2. 工作模式
3. 发布、订阅模式
4. 路由模式
5. 主题模式
6. 发布确认模式

#### 2.1 Hello World 简单模式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181221114009759.png)

1. 消息产生者将消息放入队列
2. 消息的消费者(consumer) 监听(while) 消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除(隐患 消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失)
2. 应用场景：聊天(中间有一个过度的服务器；p端，c端)

#### 2.2 Work queues 工作模式(资源的竞争)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181221114036231.png)

1. 消息产生者将消息放入队列消费者可以有多个，消费者1，消费者2，同时监听同一个队列，消息被消费，C1  C2共同争抢当前的消息队列内容，谁先拿到谁负责消费消息(隐患,高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关(syncronize，与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)
2. 应用场景：红包；大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲，直接将任务扔到消息队列中，空闲的系统自动争抢)

#### 2.3 Publish/Subscribe发布订阅(共享资源)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181221114050657.png)

1. X代表交换机，erlang 消息产生者是代码完成，代码的执行效率不高，消息产生者将消息放入交换机，交换机发布订阅把消息发送到所有消息队列中，对应消息队列的消费者拿到消息进行消费
2. 相关场景：邮件群发，群聊天，广播(广告)

#### 2.4 Routing路由模式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181221114420299.png)

1. 消息生产者将消息发送给交换机按照路由判断，路由是字符串(info) 当前产生的消息携带路由字符(对象的方法)，交换机根据路由的key，只能匹配上路由key对应的消息队列，对应的消费者才能消费消息
2. 根据业务功能定义路由字符串
3. 从系统的代码逻辑中获取对应的功能字符串，将消息任务扔到对应的队列中业务场景：error 通知；EXCEPTION；错误通知的功能；传统意义的错误通知；客户通知；利用key路由，可以将程序中的错误封装成消息传入到消息队列中，开发者可以自定义消费者，实时接收错误

#### 2.5 Topics 主题模式(路由模式的一种)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181221114208408.png)

1. 星号井号代表通配符
2. 星号代表多个单词,井号代表一个单词
3. 路由功能添加模糊匹配
4. 消息产生者产生消息，把消息交给交换机
5. 交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费



#### 2.6 Publish Confirms 发布确认模式

Publisher Confirms 是实现可靠发布的 RabbitMQ 扩展。当通道上启用发布者确认时，客户端发布的消息由代理异步确认，这意味着它们已在服务器端得到处理。



### 3. 原理名词解释

![image-20220704000355063](C:\Users\AruNi、\AppData\Roaming\Typora\typora-user-images\image-20220704000355063.png)

- Broker

  接收和分发消息的应用，RabbitMQ Server 就是 Message Broker

- Virtual host

  出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ  server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等

- Connection

  publisher／consumer 和 broker 之间的 TCP 连接

- Channel

  如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection  的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread  创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别  channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP  connection 的开销

- Exchange

  message 到达 broker  的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct  (point-to-point), topic (publish-subscribe) and fanout (multicast)

- Queue

  消息最终被送到这里等待 consumer 取走

- Binding

  exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据



















































