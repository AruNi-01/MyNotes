## 操作系统基础

### 1. 什么是操作系统

- 操作系统本质上是一个运行在计算机上的 **软件程序**，用于 **管理计算机硬件和软件资源**。举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
- 操作系统的存在 **屏蔽了硬件层的复杂性**。
- 操作系统的 **内核**（Kernel）是核心部分，它负责系统的 **内存、硬件设备、文件系统、以及应用程序** 的管理。内核是连接 **应用程序和硬件的桥梁**，决定着系统的性能和稳定性。

![操作系统是什么](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202210202234350.png)

### 2. 系统调用

在理解系统调用之前，先来了解一下用户态和内核态。

根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

- **用户态**：用户态运行的进程只可以读取 **用户程序的数据**；
- **内核态**：系统态运行的进程或程序几乎可以访问计算机的 **任何资源**，不受限制。

内核程序执行在内核态，用户程序执行在用户态。



什么是系统调用：

- 我们运行的程序基本都是运行在用户态，如果想要 **调用操作系统提供的系统级别的子功能** 时，就需要系统调用了。
- 也就是说我们运行的用户程序中，凡是与 **系统态级别资源** 有关的操作（如文件管理、进程控制、内存管理等），都必须 **通过系统调用方式向操作系统提出服务请求**，由操作系统代为完成。

应用程序如果需要进入内核空间，就需要通过系统调用，系统调用的过程：

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202210171117048.png)

当应用程序使用系统调用时，会产生一个 **中断**。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。



系统调用按功能大致可分为如下几类：

- **设备管理**，完成设备的请求与释放，设备启动等功能；
- **文件管理**，完成文件的读、写、创建及删除等功能；
- **进程控制**，完成进程的创建、撤销、阻塞及唤醒等功能；
- **进程通信**，完成进程之间的消息传递或信号传递等功能；
- **内存管理**，完成内存的分配、回收、作业占用内存区大小和地址等功能；

## 进程和线程

### 1. 进程和线程的区别

从 Java 内存区域（JVM）的角度来说：

- 一个进程中可以有多个线程，多个线程共享进程 **堆** 和 **方法区**（JDK 8 后的 **元空间**）的资源；
- 但是每个线程有自己的 **程序计数器**、**虚拟机栈** 和 **本地方法栈**；

![Java 运行时数据区域（JDK1.8 之后）](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202210202238443.png)

总结：

- 线程是进程划分的更小的运行单位，一个进程在执行的过程中可以产生多个线程；
- 进程是独立的，而线程之间可能会互相影响；
- 线程执行开销小，但不利于资源的管理和保护；而进程恰恰相反；



### 2. 进程有哪几种状态

当一个线程开始运行时，它可能会经历下面这三种状态：

- 运行状态（Running）：该时刻进程占用 CPU；
- 就绪状态（Ready）：可运行，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源 (处理器分配的时间片) 即可运行；
- 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待 IO 操作的完成）而暂时停止运行，这时即使给它 CPU 的控制权，它也无法运行；

这三种状态的转换关系如下：

![进程3种状态](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202210202245585.png)



进程在未运行时还有两个基本的状态：

- 创建状态（New）：进程正在被创建的状态；
- 结束状态（Exit）：进程正在从系统中消失时的状态；

![进程5种状态](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202210202246424.png)



### 3. 进程间的通信方式

有 7 种常见的进程间的通信方式：

1. **管道/匿名管道**（Pipes）：用于具有 **亲缘关系** 的父子进程间或者兄弟进程之间的通信；
2. **有名管道**（Names Pipes）：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 **FIFO**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；
3. **信号**（Signal）：信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。
4. **消息队列**（MQ）：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；有名管道：存在于实际的磁盘介质或者文件系统）不同的是 **消息队列存放在内核中**，只有在内核重启 (即，操作系统重启) 或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的 **随机查询**，消息不一定要以先进先出的次序读取，也可以**按消息的类型读取**。比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点**；
5. **信号量**（Semaphores）：信号量是一个计数器，用于 **多线程对共享数据的访问**，信号量的意图在于 **进程间同步**。这种通信方式主要用于解决与同步相关的问题并避免竞争条件；
6. **共享内存**（Shared memory）：使得多个进程可以 **访问同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种 **同步操作**，如互斥锁和信号量等。可以说这是 **最有用的进程间通信方式**；
7. **套接字**（Sockets）：此方法主要用于在客户端和服务器之间通过网络进行通信。它可用于不同机器间的进程通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



### 4. 线程间的同步方式

线程同步是两个或者多个共享关键资源的线程并发执行，应该同步线程以避免关键的资源使用冲突。

操作系统一般有下面三种线程同步方式：

1. **互斥量**（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为 **互斥对象只有一个**，所以可以保证共享资源不会被多个线程同时访问。比如 Java 中的 Synchronized 关键字和各种 Lock 都是这种机制；
2. **信号量**（Semaphore）：它允许同一时刻多个线程访问资源，但是需要控制同一时刻访问资源的最大线程数量，通常信号量就表示资源的数量，对应的变量是⼀个整型（ sem ）变量；
   - 有两个 **原子操作的系统调用函数** 来控制信号量，分别是：
     - *P* 操作：将 sem 减 1 ，相减后，如果 sem < 0 ，则进程/线程进入阻塞等待，当 sem > 0时，可以获准进入临界区（把对共享资源访问的程序片段称为`临界区`）；
     - *V* 操作：将 sem 加 1 ，相加后，如果 sem >= 0 ，唤醒一个等待中的进程/线程，可以获准进入临界区；
     - P 操作是用在进⼊临界区之前，V 操作是用在离开临界区之后，这两个操作是必须 **成对出现**。
3. **事件**（Event）：Wait/Notify，Event 是 windows 的一种内核对象，通过通知操作的方式来保持多线程同步；



### 5. 进程的调度算法

进程调度就是确定 **某一个时刻 CPU 运行哪个进程** 以实现 **最大 CPU 利用率**，常见的进程调度算法有：

- **先到先服务**：非抢占式的调度算法，按照 **请求的顺序** 进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。
- **短作业优先**：非抢占式的调度算法，按 **估计运行时间最短的顺序** 进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- **最短剩余时间优先**：**短作业优先的抢占式版本**，**按剩余运行时间的顺序** 进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
- **优先级调度**：为每个进程分配一个优先级，**按优先级进行调度**。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
- **时间片轮转**：一种最古老，最简单，最公平且使用最广的算法。将所有就绪进程按先来先服务的原则排成一个队列，每次调度时，把 **CPU 时间分配给队首进程**，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟 **中断**，调度程序便停止该进程的执行，并将它送往就绪 **队列的末尾**，同时 **继续把 CPU 时间分配给队首的进程**。























