# MySQL数据库基础

数据库(Database) 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 数据库管理系统（DataBase- Management System，DBMS） 创建和操纵的容器。DBMS 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。

我们常说 XX 数据库，其实实质上是 XX 数据库管理系统。目前，较为流行的数据库管理系统有 MySQL、SQL Server、Oracle 等。
数据库有两种类型，分别是 关系型数据库 和 非关系型数据库。

| **数据库类型** | **定义**                                                     | **优点**                                                     | **缺点**                                                     | **常见**                                           |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| 关系型数据库   | 建立在关系模型基础上，由多张能互相连接的 **表** 组成的数据库 | 1）使用表结构，格式一致，易于维护；2）使用 SQL 语句，可用于复杂查询；3）数据存储在磁盘中，安全性高 | 1）读写性能比较差；2）建立在关系模型上，不可避免空间浪费；3）固定的表结构，灵活度较低 | MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等 |
| 非关系型数据库 | 非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 **对象** 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 | 1) 存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛；2）可轻松进行海量数据的维护和处理；3）具有可扩展、高并发、高稳定性、成本低的优势；4）可以实现数据的分布式处理 | 1）不提供 SQL 支持；2）无事务处理，无法保证数据的完整性和安全性；3）功能没有关系型数据库完善 | Neo4j，Redis，MongoDB 等                           |



## 1. 三大范式

### 1.1 第一范式（确保每列保持原子性）

第一范式是最基本的范式。如果数据库表中的**所有字段值都是不可分解的原子值**，就说明该数据库表满足了第一范式。

第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819999.png)

上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。

### 1.2 第二范式（确保表中的每列都和主键相关）

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的**每一列都和主键相关，非主键列完全依赖于主键，而不能只与主键的某一部分相关（主要针对联合主键而言）**。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819000.png)

这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。

而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819001.png)

这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。



### 1.3 第三范式（确保每列都和主键列直接相关，而不是间接相关（传递依赖））

第三范式需要确保数据表中的**每一列数据都和主键直接相关，而不能间接相关**。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819002.png)

这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。



### 1.4 范式的应用

我们来逐步搞定一个论坛的数据库，有如下信息：
（1） 用户：用户名，email，主页，电话，联系地址 （2） 帖子：发帖标题，发帖内容，回复标题，回复内容

第一次我们将数据库设计为仅仅存在表：
用户名 email 主页 电话 联系地址 发帖标题 发帖内容 回复标题 回复内容 

这个数据库表符合第一范式，但是没有任何一组候选关键字能决定数据库表的整行，唯一的关键字段用户名也不能完全决定整个元组。我们需要增加"发帖ID"、"回复ID"字段，即将表修改为：
用户名 email 主页 电话 联系地址 发帖ID 发帖标题 发帖内容 回复ID 回复标题 回复内容 

这样数据表中的关键字(用户名，发帖ID，回复ID)能决定整行：
(用户名,发帖ID,回复ID) → (email,主页,电话,联系地址,发帖标题,发帖内容,回复标题,回复内容)

但是，这样的设计不符合第二范式，因为存在如下决定关系：
(用户名) → (email,主页,电话,联系地址) (发帖ID) → (发帖标题,发帖内容) (回复ID) → (回复标题,回复内容)

即非关键字段部分函数依赖于候选关键字段，很明显，这个设计会导致大量的数据冗余和操作异常。

我们将数据库表分解为（带下划线的为关键字）：
（1） 用户信息：用户名，email，主页，电话，联系地址 （2） 帖子信息：发帖ID，标题，内容 
（3） 回复信息：回复ID，标题，内容 
（4） 发贴：用户名，发帖ID
（5） 回复：发帖ID，回复ID

这样的设计是满足第1、2、3范式和BCNF范式要求的，但是这样的设计是不是最好的呢？

不一定。观察可知，第4项"发帖"中的"用户名"和"发帖ID"之间是1：N的关系，因此我们可以把"发帖"合并到第2项的"帖子信息"中；第5项"回复"中的"发帖ID"和"回复ID"之间也是1：N的关系，因此我们可以把"回复"合并到第3项的"回复信息"中。这样可以一定量地减少数据冗余，新的设计为：
（1） 用户信息：用户名，email，主页，电话，联系地址 （2） 帖子信息：用户名，发帖ID，标题，内容 
（3） 回复信息：发帖ID，回复ID，标题，内容

数据库表1显然满足所有范式的要求；

数据库表2中存在非关键字段"标题"、"内容"对关键字段"发帖ID"的部分函数依赖，即不满足第二范式的要求，但是这一设计并不会导致数据冗余和操作异常；

数据库表3中也存在非关键字段"标题"、"内容"对关键字段"回复ID"的部分函数依赖，也不满足第二范式的要求，但是与数据库表2相似，这一设计也不会导致数据冗余和操作异常。

由此可以看出，并不一定要强行满足范式的要求，对于1：N关系，当1的一边合并到N的那边后，N的那边就不再满足第二范式了，但是这种设计反而比较好！

对于M：N的关系，不能将M一边或N一边合并到另一边去，这样会导致不符合范式要求，同时导致操作异常和数据冗余。

对于1：1的关系，我们可以将左边的1或者右边的1合并到另一边去，设计导致不符合范式要求，但是并不会导致操作异常和数据冗余。



==结论：==
满足范式要求的数据库设计是结构清晰的，同时可避免数据冗余和操作异常。这并意味着不符合范式要求的设计一定是错误的，在数据库表中存在1：1或1：N关系这种较特殊的情况下，合并导致的不符合范式要求反而是合理的。
在设计数据库的时候，一定要时刻考虑范式的要求。



#### 1.4.1要善于识别与正确处理多对多的关系 

若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。 

〖例3〗：在“图书馆信息系统”中，“图书”是一个实体，“读者”也是一个实体。这两个实体之间的关系，是一个典型的多对多关系：一本图书在不同时间可以被多个读者借阅，一个读者又可以借多本图书。为此，要在二者之间增加第三个实体，该实体取名为“借还书”，它的属性为：借还时间、借还标志(0表示借书，1表示还书)，另外，它还应该有两个外键(“图书”的主键，“读者”的主键)，使它能与“图书”和“读者”连接。

#### 1.4.2 正确认识数据冗余 

主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚，事实上有许多人还不清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。 

〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。



## 2. 约束

### 2.1 列级约束条件

约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。

列级约束有六种：主键Primary key、外键Foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null

- 非空约束（NOT NULL）：保证该字段值一定不为空；
- 默认约束（DEFAULT）：保证字段有默认值；
- 主键约束（PRIMARY KEY）：标志一列或者多列，并保证其值在表内的唯一性；
- 外键约束（FOREIGN KEY）：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；
- 唯一约束（UNIQUE）： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；
- 检查约束（CHECK）：限制一列的可用值范围。

### 2.2 表级约束条件

表级约束有四种：主键、外键、唯一、检查

示例：

```sql
[CONSTRAINT <外键名>] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES <主表名> 主键列1 [，主键列2，…]
```



### 2.3 主键/外键/索引的区别

|        |                    主键                    |                         外键                         |                索引                |
| :----: | :----------------------------------------: | :--------------------------------------------------: | :--------------------------------: |
| 定义： | 唯一标识一条记录，不能有重复的，不允许为空 | 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 | 该字段没有重复值，但可以有一个空值 |
| 作用： |             用来保证数据完整性             |               用来和其他表建立联系用的               |        是提高查询排序的速度        |
| 个数： |               主键只能有一个               |                 一个表可以有多个外键                 |      一个表可以有多个唯一索引      |

 

### 2.4 MySQL外键设置中各值的作用

==cascade方式：==

在父表上update/delete记录时，同步update/delete掉子表的匹配记录 

==set null方式：==
在父表上update/delete记录时，将子表上匹配记录的列设为null
要注意子表的外键列不能为not null  

==No action方式：==
如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作  

==Restrict方式：==
同no action, 都是立即检查外键约束

==Set default方式：==
父表有变更时,子表将外键列设置成一个默认的值 但Innodb不能识别

## 3. SQL语句

SQL 是 结构化查询语言（Structured Query Language） 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。

SQL语句不区分大小写（关键字推荐使用大写），它支持多行，使用 `；` 号进行结尾

SQL也支持注释，通过使用 ` --` 或者 ` # ` 来编写注释内容，也可以使用 ` /* */ ` 来进行多行注释

四种类型的SQL语言：

- 数据查询语言(Data Query Language, DQL) 基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。
- 数据操纵语言(Data Manipulation Language, DML)是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。
- 数据库定义语言DDL(Data Definition Language),是用于描述数据库中要存储的现实世界实体的语言。
- DCL (Data Control Language)是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括(grant,deny,revoke等)语句。在默认状态下，只有sysadmin,dbcreator,db owner或db_ securityadmin等 人员才有权力执行DCL。

平时所说的CRUD就是增删改查（Create/Retrieve/Update/Delete）



### 3.1 数据库定义语言（DDL）

**数据库操作**
我们可以通过`create database`来**创建一个数据库**：

`create database 数据库名`

为了能够支持中文，我们在创建时可以设定编码格式：

`CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;`

如果我们创建错误了，我们可以将此数据库删除，通过使用`drop database`来删除一个数据库：

`drop database 数据库名`

#### 3.1.1 创建表

数据库创建完成后，我们一般通过`create table`语句来创建一张表：

```sql
create table 表名(列名 数据类型[列级约束条件],
             列名 数据类型[列级约束条件],
             ...
             [,表级约束条件])
```



**SQL中的数据类型（不限于以下类型）**

以下的数据类型用于**字符串**存储：

- char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。
- varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。

以下数据类型用于存储**数字**：

- smallint用于存储小的整数，范围在 (-32768，32767)
- int用于存储一般的整数，范围在 (-2147483648，2147483647)
- bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)
- float用于存储单精度小数
- double用于存储双精度的小数

以下数据类型用于存储**时间**：

- date存储日期
- time存储时间
- year存储年份
- datetime用于混合存储日期+时间



**什么是超键？什么是主键？**

- **超 键**：在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
- **候选键**：是最小超键，即没有冗余元素的超键。
- **主 键**：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。
- **外 键**：在一个表中存在的另一个表的主键称此表的外键，外键可以有重复的, 可以是空值。外键是用来和其他表建立联系用的。



#### 3.1.2 修改表

如果我们想修改表结构，我们可以通过`alter table`来进行修改：

```sql
ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]]
							 [DROP COLUMN 列名[restrict|cascade]]
							 [ALTER COLUMN 列名 新数据类型]
```

我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。

示例：在teacher表中新增sex列

```sql
mysql> alter table teacher add sex enum('男', '女') not null default '男';
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0
```



#### 3.1.3 删除表

我们可以通过`drop table`来删除一个表：

```sql
DROP TABLE 表名[restrict|cascade]
```

其中restrict和cascade上面的效果一致。

示例：创建一张test测试表，再将其删除

```sql
mysql> create table test(id int not null);
Query OK, 0 rows affected (0.03 sec)

mysql> drop table test;
Query OK, 0 rows affected (0.00 sec)
```



### 3.2 数据库操纵语言（DML）

前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。

#### 3.2.1 插入数据

通过使用`insert into`语句来向数据库中插入一条数据（一条记录）：

```sql
INSERT INTO 表名 VALUES(值1, 值2, 值3)
```



如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：

```sql
INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2)
```



我们也可以一次性向数据库中插入多条数据：

```sql
INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2)
```



我们来试试看向我们刚刚创建的表中添加三条数据。

```sql
mysql> insert into student(sid, name, sex) values(444, '小王', '男');
Query OK, 1 row affected (0.00 sec)

mysql> insert into student values(555,'小美','女'), (666,'小丽','女');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
```



#### 3.2.2 修改数据

我们可以通过`update`语句来更新表中的数据：

```sql
UPDATE 表名 SET 列名=值 , ... WHERE 条件
```

注意，SQL语句中的等于判断是`=`

**警告：**如果忘记添加`WHERE`字句来限定条件，将使得整个表中此列的所有数据都被修改！

示例：将刚刚添加的小王改成小刚

```sql
mysql> update student set name='小刚' where sid=444;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```



#### 3.2.3 删除数据

我们可以通过使用`delete`来删除表中的数据：

```sql
DELETE FROM 表名
```

通过这种方式，将删除表中全部数据，我们也可以使用`where`来添加条件，只删除指定的数据：

```sql
DELETE FROM 表名 WHERE 条件
```

示例：删除小刚

```sql
mysql> delete from student where name='小刚';
Query OK, 1 row affected (0.00 sec)
```



`TRUNCATE`：完全清空一个表的数据，但表的结构和索引约束不会变

```sql
TRUNCATE 表名
```



> delete和TRUNCATE的区别

- 相同点：都能删除数据，都不会删除表的结构
- 不同点：
  - TRUNCATE：重新设置 自增值（自增值会归零）；不会影响事务
  - delete：不会影响自增的值



`delete`删除的问题，重启数据库后：

- InnoDB：自增列会从1开始（存在内存中，断电即失）
- MyISAM：继续从上一个自增量开始（存在文件中，不会丢失）



***

### 3.3 数据库查询语言（DQL）

数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。

> SELECT语法
>
> (ps.顺序不能乱)

```sql
SELECT [ALL | DISTINCT]
{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}
FROM table_name [as table_alias]
  [left | right | inner join table_name2] 	 -- 联合查询
  [WHERE ...] 		 -- 指定结果需满足的条件
  [GROUP BY ...] 	 -- 指定结果按照哪几个字段来分组
  [HAVING] 	 		-- 过滤分组的记录必须满足的次要条件
  [ORDER BY ...]  		-- 指定查询记录按一个或多个条件排序
  [LIMIT {[offset,]row_count | row_countOFFSET offset}];
   -- 指定查询的记录从哪条至哪条
```



#### 3.3.1 单表查询

单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用`select`语句来进行单表查询：

```sql
-- 指定查询某一列数据
SELECT 列名[,列名] FROM 表名
-- 会以别名显示此列
SELECT 列名 (as) 别名 FROM 表名
-- 查询所有的列数据
SELECT * FROM 表名
-- 只查询不重复的值
SELECT DISTINCT 列名 FROM 表名
```

我们也可以添加`where`字句来限定查询目标：

```sql
SELECT * FROM 表名 WHERE 条件
```



`函数：Concat` 

```sql
mysql> select concat('姓名：', name) as 名字信息 from student;
```

```
+-----------------+
| 名字信息        |
+-----------------+
| 姓名：丽丽      |
| 姓名：大亮      |
| 姓名：大张      |
| 姓名：大虎      |
| 姓名：大黎      |
| 姓名：小亮      |
| 姓名：小明      |
| 姓名：小池      |
| 姓名：小红      |
| 姓名：小美      |
+-----------------+
10 rows in set (0.00 sec)
```



示例：

```sql
mysql> select name,sex from student;
+--------+-----+
| name   | sex |
+--------+-----+
| 小明   | 男  |
| 小红   | 女  |
| 小亮   | 男  |
| 小美   | 女  |
| 小丽   | 女  |
+--------+-----+
5 rows in set (0.00 sec)

mysql> select * from student;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 222 | 小红   | 女  |
| 333 | 小亮   | 男  |
| 555 | 小美   | 女  |
| 666 | 小丽   | 女  |
+-----+--------+-----+
5 rows in set (0.00 sec)

mysql> select distinct sex from student;		#sex去重，只有男女
+-----+
| sex |
+-----+
| 男  |
| 女  |
+-----+
2 rows in set (0.00 sec)

mysql> select * from student where sid=555;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 555 | 小美   | 女  |
+-----+--------+-----+
1 row in set (0.00 sec)
```







#### 3.3.2 常用查询条件（WHERE后）

* 一般的比较运算符，包括=、>、<、>=、<=、!=等。
* 是否为空：null、not null
* 是否在集合中：in、not in
* 字符==模糊==匹配：like，not like
  * %：0到任意个字符
  * _：只有一个字符

* 多重条件连接查询：and、or、not
* %为任意，放在前面表示前面为任意，后面是条件；放在后面相反；前后都放表示只要中间的数据满足条件即可。

我们来尝试使用一下上面这几种条件。

示例：

```sql
mysql> select * from student  where name not in('小明','小红');
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 333 | 小亮   | 男  |
| 555 | 小美   | 女  |
| 666 | 小丽   | 女  |
+-----+--------+-----+
3 rows in set (0.00 sec)

mysql> select * from student where name like '小%';
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 222 | 小红   | 女  |
| 333 | 小亮   | 男  |
| 555 | 小美   | 女  |
| 666 | 小丽   | 女  |
+-----+--------+-----+
5 rows in set (0.00 sec)

mysql> select * from student where name like '小%' and sex='男';
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 333 | 小亮   | 男  |
+-----+--------+-----+
2 rows in set (0.00 sec)
```



#### 3.3.3 排序查询(order by)

我们可以通过`order by`来将查询结果进行排序：

```sql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC
```

使用==ASC表示升序排序==，使用==DESC表示降序排序==，默认为升序。

我们也可以可以同时添加多个排序：

```sql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC
```

这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。

示例：

```sql
mysql> select * from student order by sid desc;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 666 | 小丽   | 女  |
| 555 | 小美   | 女  |
| 333 | 小亮   | 男  |
| 222 | 小红   | 女  |
| 111 | 小明   | 男  |
+-----+--------+-----+
5 rows in set (0.00 sec)

mysql> select * from student order by sex asc,sid desc;			#先按sex升序，再按sid降序
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 333 | 小亮   | 男  |
| 111 | 小明   | 男  |
| 666 | 小丽   | 女  |
| 555 | 小美   | 女  |
| 222 | 小红   | 女  |
+-----+--------+-----+
5 rows in set (0.00 sec)
```



#### 3.3.4 聚集函数(统计)

**聚集函数**一般用作**统计**，包括：

* `count([distinct]*)`统计所有的行数（distinct表示去重再统计，下同）
* `count([distinct]列名)`统计某列的值总和
* `sum([distinct]列名)`求一列的和（注意必须是数字类型的）
* `avg([distinct]列名)`求一列的平均值（注意必须是数字类型）
* `max([distinct]列名)`求一列的最大值
* `min([distinct]列名)`求一列的最小值

一般聚集函数是这样使用的：

```sql
SELECT count(distinct 列名) FROM 表名 WHERE 条件 
```

示例：

```sql
mysql> select count(*) from student;
+----------+
| count(*) |
+----------+
|        5 |
+----------+
1 row in set (0.00 sec)

mysql> select count(distinct sex) from student;
+---------------------+
| count(distinct sex) |
+---------------------+
|                   2 |
+---------------------+
1 row in set (0.00 sec)

mysql> select count(sex) from student where sex='女';
+------------+
| count(sex) |
+------------+
|          3 |
+------------+
1 row in set (0.00 sec)
```



**count(\*) 和 count(1)和count(列名)区别** 

- count(*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL 
- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL 
- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计

#### 3.3.5 分组和分页查询（group by）

- 通过使用`group by`来对查询结果进行分组，它需要结合聚合函数一起使用：

```sql
SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名
```

```sql
mysql> select count(*),sex from student group by sex;
+----------+-----+
| count(*) | sex |
+----------+-----+
|        2 | 男  |
|        3 | 女  |
+----------+-----+
2 rows in set (0.00 sec)
```



- 我们还可以添加`having`来==限制分组条件==：

```sql
SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件
```

```sql
mysql> select count(*),sex from student group by sex having sex='男';
+----------+-----+
| count(*) | sex |
+----------+-----+
|        2 | 男  |
+----------+-----+
1 row in set (0.00 sec)
```



- 我们可以通过`limit`来限制查询的数量，只取前n个结果：

```sql
SELECT * FROM 表名 LIMIT 数量
```

```sql
mysql> select * from student limit 3;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 222 | 小红   | 女  |
| 333 | 小亮   | 男  |
+-----+--------+-----+
3 rows in set (0.00 sec)
```



- 我们也可以进行分页：

```sql
SELECT * FROM 表名 LIMIT 起始位置,数量
```

```sql
mysql> select * from student limit 0,3;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 222 | 小红   | 女  |
| 333 | 小亮   | 男  |
+-----+--------+-----+
3 rows in set (0.00 sec)


--分页查寻所有信息的示例：
mysql> select * from student limit 0,3;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 111 | 小明   | 男  |
| 222 | 小红   | 女  |
| 333 | 小亮   | 男  |
+-----+--------+-----+
3 rows in set (0.00 sec)

mysql> select * from student limit 3,3;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 555 | 小美   | 女  |
| 666 | 丽丽   | 女  |
| 888 | 小池   | 男  |
+-----+--------+-----+
3 rows in set (0.00 sec)

mysql> select * from student limit 6,3;
+------+--------+-----+
| sid  | name   | sex |
+------+--------+-----+
| 2000 | 大虎   | 男  |
| 2001 | 大亮   | 男  |
| 2002 | 大张   | 女  |
+------+--------+-----+
3 rows in set (0.00 sec)

mysql> select * from student limit 9,3;
+------+--------+-----+
| sid  | name   | sex |
+------+--------+-----+
| 2003 | 大黎   | 女  |
+------+--------+-----+
1 row in set (0.00 sec)
```

第一页：limit 0, 3		起始位置(1-1) * 3

第二页：limit 3, 3		起始位置(2-1) * 3 

第三页：limit 6, 3		起始位置(3-1) * 3

第四页：limit 9, 3		起始位置(4-1) * 3

第n页： limit (n-1) * pageSize, pageSize		起始位置(n-1) * pageSize

> pageSize：页面大小
>
> (n-1) * pageSize：起始位置值
>
> n：当前页数
>
> 数据总数/页面大小 = 总页数



#### 3.3.6 多表查询

- 多表查询是同时查询的两个或两个以上的表，多表查询会通过连接转换为单表查询。

```sql
SELECT * FROM 表1, 表2
```

直接这样查询会得到两张表的**笛卡尔积**，也就是**每一项数据和另一张表的每一项数据都结合一次**，会产生庞大的数据。如下：

```sql
mysql> select * from student,teacher;
+-----+--------+-----+-----+-----------+-----+
| sid | name   | sex | tid | name      | sex |
+-----+--------+-----+-----+-----------+-----+
| 111 | 小明   | 男  | 123 | 张老师    | 男  |
| 111 | 小明   | 男  | 456 | 陆老师    | 男  |
| 222 | 小红   | 女  | 123 | 张老师    | 男  |
| 222 | 小红   | 女  | 456 | 陆老师    | 男  |
| 333 | 小亮   | 男  | 123 | 张老师    | 男  |
| 333 | 小亮   | 男  | 456 | 陆老师    | 男  |
| 555 | 小美   | 女  | 123 | 张老师    | 男  |
| 555 | 小美   | 女  | 456 | 陆老师    | 男  |
| 666 | 小丽   | 女  | 123 | 张老师    | 男  |
| 666 | 小丽   | 女  | 456 | 陆老师    | 男  |
+-----+--------+-----+-----+-----------+-----+
10 rows in set (0.00 sec)
```



- 可以添加WHERE条件来筛选

```sql
SELECT * FROM 表1, 表2 WHERE 条件
```

这样，只会从笛卡尔积的结果中得到满足条件的数据。

**注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。

```sql
mysql> select * from student,teacher where teacher.name='陆老师';
+-----+--------+-----+-----+-----------+-----+
| sid | name   | sex | tid | name      | sex |
+-----+--------+-----+-----+-----------+-----+		
| 111 | 小明   | 男  | 456 | 陆老师    | 男  |
| 222 | 小红   | 女  | 456 | 陆老师    | 男  |
| 333 | 小亮   | 男  | 456 | 陆老师    | 男  |
| 555 | 小美   | 女  | 456 | 陆老师    | 男  |
| 666 | 小丽   | 女  | 456 | 陆老师    | 男  |
+-----+--------+-----+-----+-----------+-----+
5 rows in set (0.00 sec)
```

表是几行几列取决于数据多的表，数据少的表就会用重复的数据填充。

#### 3.3.7 自身连接查询

自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：

```sql
SELECT * FROM 表名 别名1, 表名 别名2
```

其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。

```sql
mysql> select * from teacher t1,teacher t2;
+-----+-----------+-----+-----+-----------+-----+
| tid | name      | sex | tid | name      | sex |
+-----+-----------+-----+-----+-----------+-----+
| 123 | 张老师    | 男  | 123 | 张老师    | 男  |
| 456 | 陆老师    | 男  | 123 | 张老师    | 男  |
| 123 | 张老师    | 男  | 456 | 陆老师    | 男  |
| 456 | 陆老师    | 男  | 456 | 陆老师    | 男  |
+-----+-----------+-----+-----+-----------+-----+
4 rows in set (0.00 sec)
```



- 查询表1(t1)的name，然后给t1的name取别名 '姓名' (能使查询结果用该别名来显示) ，限制条件为表1(t1)和表2(t2)中tid相同的老师。

```sql
mysql> select t1.name '姓名' from teacher t1,teacher t2 where t1.tid=t2.tid;
+-----------+
| 姓名      |
+-----------+
| 张老师    |
| 陆老师    |
+-----------+
2 rows in set (0.00 sec)
```



#### 3.3.8 外连接查询 [重要]

外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：

* 通过使用`inner join`进行内连接（连接后加`on`来连接条件），只会返回两个表满足条件的交集部分：

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819003.png)

示例：查询student表和teach表中sid相同的数据（可以查询哪个tid的老师教此sid的学生）：

```sql
mysql> select * from student inner join teach on student.sid=teach.sid;
+-----+--------+-----+-----+-----+
| sid | name   | sex | tid | sid |
+-----+--------+-----+-----+-----+
| 111 | 小明   | 男  | 123 | 111 |
| 222 | 小红   | 女  | 123 | 222 |
| 333 | 小亮   | 男  | 456 | 333 |
| 555 | 小美   | 女  | 456 | 555 |
| 666 | 小丽   | 女  | 123 | 666 |
+-----+--------+-----+-----+-----+
5 rows in set (0.00 sec)
```



- 通过使用`left join`进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用`null`来代替（右连接`right join`同理，只是反过来而已，这里就不再介绍了）：

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819004.png)

示例：先在student表中插入一个数据，该学生没有和teach表关联，在用左连接进行查询：

```sql
mysql> insert into student values(888,'小池','男');
Query OK, 1 row affected (0.00 sec)

mysql> select * from student left join teach on student.sid=teach.sid;
+-----+--------+-----+------+------+
| sid | name   | sex | tid  | sid  |
+-----+--------+-----+------+------+
| 111 | 小明   | 男  |  123 |  111 |
| 222 | 小红   | 女  |  123 |  222 |
| 333 | 小亮   | 男  |  456 |  333 |
| 555 | 小美   | 女  |  456 |  555 |
| 666 | 小丽   | 女  |  123 |  666 |
| 888 | 小池   | 男  | NULL | NULL |
+-----+--------+-----+------+------+
6 rows in set (0.00 sec)
```



- 可以让多个表进行连接，方便查看表之间的关系。将student表与teach表相连接，再将teach表与teacher表相连接，这样就可以得到他们直接相关联的数据。

```sql
mysql> select * from student left join teach on student.sid=teach.sid
    -> left join teacher on teach.tid=teacher.tid;
+-----+--------+-----+------+------+------+-----------+------+
| sid | name   | sex | tid  | sid  | tid  | name      | sex  |
+-----+--------+-----+------+------+------+-----------+------+
| 111 | 小明   | 男  |  123 |  111 |  123 | 张老师    | 男   |
| 222 | 小红   | 女  |  123 |  222 |  123 | 张老师    | 男   |
| 333 | 小亮   | 男  |  456 |  333 |  456 | 陆老师    | 男   |
| 555 | 小美   | 女  |  456 |  555 |  456 | 陆老师    | 男   |
| 666 | 小丽   | 女  |  123 |  666 |  123 | 张老师    | 男   |
| 888 | 小池   | 男  | NULL | NULL | NULL | NULL      | NULL |
+-----+--------+-----+------+------+------+-----------+------+
6 rows in set (0.00 sec)
```



#### 3.3.9 嵌套查询

我们可以将查询的结果作为另一个查询的条件，比如：

```sql
SELECT * FROM 表名 WHERE 列名 in(=)  (SELECT 列名 FROM 表名 WHERE 条件)
```

只返回一条数据可以用=号，也可以用in，而如果是返回一组数据必须用in。所以直接**全部用in**比较安全。



我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。

1. 方式1：在上面外连接的基础上添加判断条件即可。

   ```sql
   mysql> select * from student left join teach on student.sid=teach.sid
       -> left join teacher on teach.tid=teacher.tid where teacher.name='陆老师';
   +-----+--------+-----+------+------+------+-----------+------+
   | sid | name   | sex | tid  | sid  | tid  | name      | sex  |
   +-----+--------+-----+------+------+------+-----------+------+
   | 333 | 小亮   | 男  |  456 |  333 |  456 | 陆老师    | 男   |
   | 555 | 小美   | 女  |  456 |  555 |  456 | 陆老师    | 男   |
   +-----+--------+-----+------+------+------+-----------+------+
   2 rows in set (0.00 sec)
   ```

2. 方式2：用嵌套查询。

   ```sql
   #方式一：在方式1的基础上添加限制
   mysql> select s1.sid,name,sex from student s1 left join teach t1 on s1.sid=t1.sid where tid =(select tid from teacher where name='陆老师');
   +-----+--------+-----+
   | sid | name   | sex |
   +-----+--------+-----+
   | 333 | 小亮   | 男  |
   | 555 | 小美   | 女  |
   +-----+--------+-----+
   2 rows in set (0.00 sec)
   
   #方式二(用in替换=号是因为查询出来的是一组数据，用in接收)：
   mysql> select * from student where sid in (select sid from teach where tid = (select tid from teacher where name = '陆老师'));
   /*select tid from teacher where name = '陆老师'   查询出来的tid只有一个，所以用=，而该tid的老师所教的sid的学生不止一个，所以用in接收*/
   +-----+--------+-----+
   | sid | name   | sex |
   +-----+--------+-----+
   | 333 | 小亮   | 男  |
   | 555 | 小美   | 女  |
   +-----+--------+-----+
   2 rows in set (0.00 sec)
   ```

   

***

### 3.4 数据库控制语言（DCL）

庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。

#### 3.4.1 创建用户

我们可以通过`create user`来创建用户：

```sql
CREATE USER 用户名 identified by 密码;
```

也可以不带密码：

```sql
CREATE USER 用户名;
```

我们可以通过@来限制用户登录的登录IP地址，`%`表示匹配所有的IP地址，默认使用的就是任意IP地址。

```sql
mysql> create user user01 identified by '123456';
Query OK, 0 rows affected (0.01 sec)
```



#### 3.4.2 登陆用户

首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：

```sql
mysql  -u 用户名 -p
```



登录刚刚创建的用户：

```sql
C:\Users\AruNi、>mysql -u user01 -p
Enter password: ******
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.7.35 MySQL Community Server (GPL)

Copyright (c) 2000, 2021, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
```

输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：

```sql
show databases;
```

我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！

```sql
mysql> show databases
    -> ;
+--------------------+
| Database           |
+--------------------+
| information_schema |
+--------------------+
1 row in set (0.00 sec)
```



#### 3.4.3 用户授权

我们可以通过使用`grant`来为一个数据库用户进行授权：

```sql
grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option]
```

其中all代表授予所有权限，当数据库和表为`*`，代表为所有的数据库和表都授权。如果在最后添加了`with grant option`，那么被授权的用户还能将已获得的授权继续授权给其他用户。

我们可以使用`revoke`来收回一个权限：

```sql
revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户
```



用root用户给user01用户study数据库的所有权限：

```sql
mysql> grant all on study.* to user01;
Query OK, 0 rows affected (0.00 sec)
```

再查看user01访问数据库的情况：

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| study              |
+--------------------+
2 rows in set (0.00 sec)
```





## 4. 视图

**视图**本质就是一个**查询的结果**，不过我们每次都可以**通过打开视图来按照我们想要的样子查看数据**。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。

### 4.1 创建视图

我们可以通过`create view`来创建视图;

```sql
CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION];
```

WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用`select`语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。

1. 若视图是由两个以上基本表导出的，则此视图不允许更新。
2. 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
3. 若视图的字段来自集函数，则此视图不允许更新。
4. 若视图定义中含有GROUP BY子句，则此视图不允许更新。
5. 若视图定义中含有DISTINCT短语，则此视图不允许更新。
6. 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade > (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。
7. 一个不允许更新的视图上定义的视图也不允许更新



### 4.2 视图和表的区别

数据库中的数据都是存储在表中的，而视图只是一个或多个表依照某个条件组合而成的结果集，一般来说你可以用update，insert，delete等sql语句修改表中的数据，而对视图只能进行select操作。

但是也存在**可更新的视图**，对于这类视图的update，insert和delete等操作最终会作用于与其相关的表中数据。因此，表是数据库中数据存储的基础，而视图只是为了满足某种查询要求而建立的一个对象。



### 4.3 删除视图

通过`drop`来删除一个视图：

```sql
drop view apptest
```



**示例：**创建sex为女的学生的视图

```sql
mysql> create view womenstuinfos as select * from student where sex='女';
Query OK, 0 rows affected (0.00 sec)
```

创建视图成功后，可以把视图当作一张表来查询：

```sql
mysql> select * from womenstuinfos;
+-----+--------+-----+
| sid | name   | sex |
+-----+--------+-----+
| 222 | 小红   | 女  |
| 555 | 小美   | 女  |
| 666 | 小丽   | 女  |
+-----+--------+-----+
3 rows in set (0.00 sec)
```

也可以到Navicat中查看：

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819005.png)



**通过嵌套将student表和teach表中sid相同的数据挑选出来，然后将sid，name，sex，tid信息创建为视图infos**（因为创建视图时不能有相同名的列(student里有sid，teach里也有sid)，所以需要用别名来创建）。因为此视图使用两个表创建出来的，所以此视图不能更新数据。

```sql
mysql> create view infos as select s.sid sid, name, sex, tid from student s left join teach t on s.sid=t.sid;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from infos;
+-----+--------+-----+------+
| sid | name   | sex | tid  |
+-----+--------+-----+------+
| 111 | 小明   | 男  |  123 |
| 222 | 小红   | 女  |  123 |
| 333 | 小亮   | 男  |  456 |
| 555 | 小美   | 女  |  456 |
| 666 | 小丽   | 女  |  123 |
| 888 | 小池   | 男  | NULL |
+-----+--------+-----+------+
6 rows in set (0.00 sec)
```

**在此基础上，在infos上定义一个新的视图infos02，就可以查看每位学生所对应的老师是谁了。**（infos视图里有name, sex, teacher表里也有name, sex；所以也需要用别名） 因为此视图是在一个不允许更新的视图infos上创建的，所以此视图也不能更新数据。

```
mysql> create view infos02 as select sid, e.name s_name, e.sex s_sex, t.name t_name from infos e left join teacher t on e.tid=t.tid;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from infos02;
+-----+--------+-------+-----------+
| sid | s_name | s_sex | t_name    |
+-----+--------+-------+-----------+
| 111 | 小明   | 男    | 张老师    |
| 222 | 小红   | 女    | 张老师    |
| 333 | 小亮   | 男    | 陆老师    |
| 555 | 小美   | 女    | 陆老师    |
| 666 | 小丽   | 女    | 张老师    |
| 888 | 小池   | 男    | NULL      |
+-----+--------+-------+-----------+
6 rows in set (0.00 sec)
```





## 5. 索引

在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：

```sql
-- 创建索引
CREATE INDEX 索引名称 ON 表名 (列名)
-- 查看表中的索引
show INDEX FROM 表名
```

我们也可以通过下面的命令删除一个索引：

```sql
drop index 索引名称 on 表名
```

虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。



**示例：**创建一个通过name来查找student表中数据的索引

```
mysql> create index searchByName on student(name);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819006.png)

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819007.png)

PRIMARY为主键的索引，默认创建的。索引方法都是BTREE(MySQL中是B+Tree)。

在Navicat中查看该索引：

![](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251819008.png)

可以修改索引类型，不同的类型相当于不同的约束。



### 5.1 MySQL索引类型

#### 5.1.1 Normal 普通索引

表示普通索引，大多数情况下都可以使用

#### 5.1.2 Unique 唯一索引

表示**唯一的，不允许重复的索引**，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique

约束唯一标识数据库表中的每一条记录，即在单表中不能用每条记录是唯一的（例如身份证就是唯一的），Unique(要求列唯一)和Primary Key(primary key = unique + not null 列唯一)约束均为列或列集合中提供了唯一性的保证，Primary Key是拥有自动定义的Unique约束，但是每个表中可以有多个Unique约束，但是只能有一个Primary Key约束。

#### 5.1.3 Full Text 全文索引

表示全文收索，在**检索长文本**的时候，效果最好，短文本建议使用Index,但是在检索的时候数据量比较大的时候，现将数据放入一个没有全局索引的表中，然后在用Create Index创建的Full Text索引，要比先为一张表建立Full Text然后在写入数据要快的很多

FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。

#### 5.1.4 SPATIAL 空间索引

空间索引是对**空间数据类型的字段**建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。



### 5.2 索引的优劣势

==优势：==

- **可以提高数据检索的效率，降低数据库的IO成本**，类似于书的目录。

- 通过**索引列对数据进行排序**，降低数据排序的成本，降低了CPU的消耗。
  - 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
  - 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。

==劣势：==

- **索引会占据磁盘空间**

- **索引虽然会提高查询效率，但是会降低更新表的效率**。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。



### 5.3 索引的数据结构

#### 5.3.1 Hash表

Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。

显然这种并不适合作为经常需要查找和范围查找的数据库索引使用。

#### 5.3.2 二叉查找树

二叉树，我想大家都会在心里有个图。

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821764.png)

二叉树特点：每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。

这个特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这就很难受很不稳定。

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821036.png)

显然这种情况不稳定的我们再选择设计上必然会避免这种情况的.

#### 5.3.3平衡二叉树

平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。查询id=6，只需要两次IO。

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821579.png)

就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：

1. 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s）


1. 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。


#### 5.3.4 B树：改造二叉树

MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。那如何降低树的高度呢？

假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）。

因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。

这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：

1. B树的节点中存储着多个元素，每个内节点有多个分叉。
2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
3. 父节点当中的元素不会出现在子节点中。
4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821295.png)

举个例子，在b树中查询数据的情况：

```
假如我们查询值等于10的数据。查询路径磁盘块1->磁盘块2->磁盘块5。

第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10<15，走左路，到磁盘寻址磁盘块2。

第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7<10，到磁盘中寻址定位到磁盘块5。

第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10=10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。

相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。

过程如图：
```

看到这里一定觉得B树就很理想了，但是前辈们会告诉你依然存在可以优化的地方：

1. B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
2. 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

#### 5.3.5 B+树：改造B树

B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题

- B树：非叶子节点和叶子节点都会存储数据。
- B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821332.png)

```
B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟这增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。
```

举个例子：

```
等值查询：
假如我们查询值等于9的数据。查询路径磁盘块1->磁盘块2->磁盘块6。

第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9<15，走左路，到磁盘寻址磁盘块2。

第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7<9<12，到磁盘中寻址定位到磁盘块6。

第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。（这里需要区分的是在InnoDB中Data存储的为行数据，而MyIsam中存储的是磁盘地址。）

过程如图：
```

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821318.png)

```
范围查询：
假如我们想要查找9和26之间的数据。查找路径是磁盘块1->磁盘块2->磁盘块6->磁盘块7。

首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。

查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。

第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9<25<26，9<26<=26，将data缓存到结果集。

主键具备唯一性（后面不会有<=26的数据），不需再向后查找，查询终止。将结果集返回给用户。
```

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821433.png)

可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构。



## 6. 触发器

触发器就像其名字一样，在某种条件下会自动触发，在`select`/`update`/`delete`时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。

触发器所依附的表称为基本表，当触发器表上发生`select`/`update`/`delete`等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）

比如在`insert`操作时，新的内容会被插入到new表中；在`delete`操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在`update`操作时，旧的内容会被移到old表中，新的内容会出现在new表中。



```sql
CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno
```

* BEFORE和AFTER的区别：
  - after：==是先完成数据的增删改，然后再触发==，触发的语句晚于监视的增删改，无法影响前面的增删改动作；也就是说先插入订单记录，再更新商品数量。当商品数量少于订单数量时造成爆库。
  - before：==先完成触发，在进行增删改==，触发语句先于监视的增删改，我们就有机会判断，修改即将发生的操作。

**PS**：如果 before 触发器失败或者语句本身失败，将不执行 after 触发器(如果有的话)



FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！

通过下面的命令来查看触发器：

```sql
SHOW TRIGGERS
```

如果不需要，我们就可以删除此触发器：

```sql
DROP TRIGGER 触发器名称
```



## 7. 事务

### 7.1 简介

当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：

```sql
SHOW ENGINES;
```

MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。



MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 insert,update,delete 语句



> 在 ==MySQL== 命令行的==默认==设置下，==事务都是自动提交==的，即执行 SQL 语句后就会马上执行 COMMIT 操作。
>
> 因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0用来禁止使用当前会话的自动提交。



一般来说，事务是必须满足4个条件（ACID）：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

我们通过以下例子来探究以下事务：

```sql
begin;   #开始事务
...
rollback;  #回滚事务

savepoint 回滚点;  #添加指定回滚点
rollback to 回滚点; #回滚到指定回滚点
...
commit; #提交事务
-- 一旦提交，就无法再进行回滚了！
```

**只要不提交，事务过程中所有的操作都不会保存到数据库中**



**事务与数据库底层数据：**

> 在事物进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据



### 7.2 事务隔离级别

> 隔离所导致的问题

==脏读==：脏读是指某一个事务读取到了其他事务未提交的数据，如果此数据回滚，将导致读取到的数据是错误的数据。

==不可重复读==：指某个事务在开启后，读取某个范围或者某条数据时，在此事务未结束的时间里内，其他事务对表内的数据进行了添加，或者更改了某一条或者多条数据后进行了提交，此时本事务读取到的数据条数与之前某时间段读取到的条数不相同，或者在读取一条数据时，两个时间段内读取到的数据值不相同。

==幻读(虚读)==：在一个事务开启后，其他事务对表中的一行或者多行进行了更改操作后进行了提交，本事务读取到的一行或多行的值仍和数量然是相同的，此时并不能读到其他事务在本事务查询时，提交的更改内容，即：其他事务对此表的更改本事务不能读到，这达成了可重复读的目的，但是读取到的数据是虚幻的。如果其他事物在此之间真实的更改了数据，则在本事务提交之前的读操作，读取到的都是未被更改前的数据，造成了读取的数据是虚幻的。



> 隔离级别

前提 同时开启了A，B两个事务但还都未开始操作数据

1. Read uncommitted (读未提交)
   B事务未提交的数据 A事务可以读取到其修改的值。在B事务开启后，对一行进行了修改，但是未进行提交，此时A事务可以读取到此行 B事务未提交的数据，这发生了脏读现象，A事务也会发生 【不可重复读】现象，即多次读取同一行或多行，得到的数量或值不相同，和【幻读】现象，即A事务之前读取到的数据被修改后，此条之前读取的数据不是真实的数据是虚幻的，这与脏读是不相同的情况下读取数据所发生的的不相同的现象，区别是一个已经被提交一个可能会回滚。
2. Read committed(读已提交)
   A事务在开启后，只能读取到已经被提交的数据，未被提交的数据，或者B事务中正在修改但未提交的数据，A事务读取不到。但是A事务在结束之前再次读取此表时，如果B事务对表中的条数或者某行数据进行了修改，A再次读取时会发生两次读取到的值或者行数不相同，此时发生了【不可重复读】的现象，且在B提交之前所读取到的值是脏数据，又发生了【脏读】现象。
3. Repeatable read(可重复读)
   A事务开启后，无论在任何时间，任何次数读取一条或者多条数据得到的结果都是相同的。在A事务未结束前，B事务对表中的数据和条数进行修改后，A事务读取到的数据仍然是A 事务开启前最后一次事务提交后表中数据的状态，直到A事务结束后再次读取时才能得到被B事务修改的数据，这样避免了【脏读】【不可重复读】的问题，但是会产生新的问题：【幻读】，即B事务在A事务中读取数据时修改了表中的数据，A事务并不能读到修改内容，在此之间A事务读到的数据都是虚幻的。
4. Serializable (序化读)
   指A事务和B事务不能同时执行，必须排队依次执行，如果A事务先被开启，则B事务不能做任何操作且包括读操作，此时事务间不会有任何交集，不会发生【脏读】【幻读】【不可重复】现象，每个事务中的操作都是安全的，但是会导致并发效率大大降低。



## 8. 数据库详细设计示例

### 1. 项目背景及需求分析

#### 1.1 项目背景

为了深刻的理解MySQL数据库，以学生成绩信息管理为例，设计一个简单、规范、高效的学生成绩信息管理系统数据库。

#### 1.2 需求分析

##### 1.2.1 信息需求

对学校而言，学生成绩管理是管理工作中重要的一环，但是高校学生的成绩管理工作量大、繁杂，人工处理非常困难。因此，借助于强大计算机的处理能力，能够把人从繁重的成绩管理工作中解脱出来，并且更加准确、安全、清晰的管理环境。

##### 1.2.2 功能需求

能够进行数据库的数据定义、数据操纵、数据控制等处理功能。具体功能应包括：可提供课程安排、课程成绩数据的添加、插入、删除、更新、查询，学生及教职工基本信息查询的功能。

##### 1.2.3 安全性与完整性要求

对于学生成绩管理系统数据库来讲，由于其主要数据是学生成绩，只能由本人以及所教老师及教务处知道，因此做好数据安全性是重中之重。另外，要求所有在校学生的信息都要录入其中，并且要设计好个别情况。

### 2. 概念结构设计

概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型。
根据学生成绩信息管理数据库设计需求抽象出学生、教师、课程、成绩四个实体，对四个实体做简化处理，默认一门课程仅被一位老师讲授。因简化后关系结构比较简单，故省略了局部E-R图。对4个实体之间的关系进行分析如下：
一位学生会被多位老师教导，一位老师会教导多位学生，所有学生与教师之间是多对多（m:n）的关系；
一位学生可能会选修多门课程，一门课程会被多位学生选修，所以学生与课程之间是多对多（m:n）的关系；
一位学生会有多项成绩（具体指某学生一门课程的分数），一项成绩仅被一位学生拥有，所以学生与成绩是一对多（1:n）的关系；
一位教师会讲授多门课程，一门课程会被一位教师讲授，所以教师与课程的关系是一对多（1:n）的关系；
一门课程拥有多项成绩，一项成绩仅被一门课程拥有，所以课程与成绩的关系是一对多（1:n）的关系；

#### 2.1 抽象出系统实体

学生（学号、姓名、班级、性别、专业、出生日期、学分）；
老师（教师编号、姓名、学院）；
课程（课程编号、教师编号、课程名称、课程学分）；
成绩（学号、课程编号、分数）；

#### 2.2 全局E-R图

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821309.png)

### 3. 逻辑结构设计

#### 3.1 关系模式

E-R图向关系模型转化要解决的问题是如何将实体型和实体间的联系转化为关系模式，如何确定这些关系模式的属性和码。
设计学生成绩管理数据库，包括学生（students）、老师（teachers）、课程（courses）、成绩（scores）四个实体，其关系模式中对每个实体定义属性如下：

students 表：学号（sid）、姓名（sname）、班级（sclass）、性别（sgender）、专业（smajor）、出生日期（sbirthday）、学分（credit_points），此为联系“students表”所对应的关系模式，学号为该关系的候选码，满足第三范式。

teachers表：教师编号（tid）、姓名（tname）、学院（tschool），此为联系“teachers表”所对应的关系模式，教师编号为该关系的候选码，满足第三范式。

courses表：课程编号（cid）、教师编号（tid）、课程名称（cname）、学分（credit_point），此为联系“courses表”所对应的关系模式，课程编号和教师编号为该关系的候选码，满足第三范式。

scores表：学号（sid）、课程编号（cid）、分数（score），此为联系“scores表”所对应的关系模式，学号和课程编号为该关系的候选码，满足第三范式。



#### 3.2 表结构

数据库中包含4个表，即学生（students）、老师（teachers）、课程（courses）、成绩（scores）。

students表的表结构

![img](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821524.png)

teachers表的表结构

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251821211.png)

courses表的表结构

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822180.png)

scores表的表结构

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822781.png)

### 4. 物理设计和实施

#### 4.1 数据库及表创建

##### 4.1.1 创建数据库

```sql
-- 如果已有该数据库，则删除
DROP DATABASE IF EXISTS StudentScore;

-- 创建数据库
CREATE DATABASE StudentScore CHARSET=UTF8;
```

##### 4.1.2 创建数据表

```sql
-- 使用数据库
USE StudentScore;

-- 创建数据表
-- table 1: students
DROP TABLE IF EXISTS students;
CREATE TABLE students(
sid INT(20) UNSIGNED PRIMARY KEY AUTO_INCREMENT NOT NULL,
sname VARCHAR(20),
sclass INT(10),
sgender VARCHAR(10),
smajor VARCHAR(20),
sbirthday DATE,
credit_points INT(5) -- 学生已修学分
);

-- table 2: teachers
DROP TABLE IF EXISTS teachers;
CREATE TABLE teachers(
tid INT(10) UNSIGNED PRIMARY KEY AUTO_INCREMENT NOT NULL,
tname VARCHAR(20),
tschool VARCHAR(20)
);

-- table 3: courses
DROP TABLE IF EXISTS courses;
CREATE TABLE courses(
cid INT(10) UNSIGNED PRIMARY KEY AUTO_INCREMENT NOT NULL,
cname VARCHAR(20),
credit_point INT(5), -- 课程学分
tid INT(10) UNSIGNED NOT NULL,
FOREIGN KEY(tid) REFERENCES teachers(tid)
);

-- table 4: scores
DROP TABLE IF EXISTS scores;
CREATE TABLE scores(
sid INT(10) UNSIGNED NOT NULL,
cid INT(10) UNSIGNED NOT NULL,
score DECIMAL(5, 2),
FOREIGN KEY(sid) REFERENCES students(sid),
FOREIGN KEY(cid) REFERENCES courses(cid)
);
```



#### 4.2 创建视图

##### 4.2.1 创建一个学生视图，要求显示学生学号、姓名、班级、性别、专业、各科成绩、平均分、总分

```sql
DROP VIEW IF EXISTS v_students_info;

CREATE VIEW v_students_info AS
SELECT  stu.sid,
		stu.sname,
		stu.sclass,
		stu.sgender,
		stu.smajor,
		sum(if(c.cname = "变形", sc.score, 0)) AS "变形",
		sum(if(c.cname = "时空穿梭", sc.score, 0)) AS "时空穿梭",
		sum(if(c.cname = "分解术", sc.score, 0)) AS "分解术",
		sum(if(c.cname = "炼器", sc.score, 0)) AS "炼器",
		sum(if(c.cname = "炼丹", sc.score, 0)) AS "炼丹",
		sum(if(c.cname = "飞行", sc.score, 0)) AS "飞行",
		round(ifnull(avg(sc.score), 0), 2) AS "平均分",
		ifnull(sum(sc.score), 0) AS "总分"
FROM 	students stu LEFT JOIN
		scores sc ON stu.sid = sc.sid LEFT JOIN
		courses c ON c.cid = sc.cid
GROUP BY stu.sid;

```

查看视图：

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822844.png)

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822485.png)



#### 4.3 创建函数

##### 4.3.1 创建一个通过学号sid获取学生信息的函数

```sql
DROP FUNCTION IF EXISTS get_student_info_by_sid;

DELIMITER //
CREATE DEFINER = CURRENT_USER FUNCTION get_student_info_by_sid(id INT)
RETURNS VARCHAR(300)
DETERMINISTIC
BEGIN
RETURN (SELECT CONCAT('姓名： ', sname, ' , ', '性别: ', sgender, ' , ', '专业：', smajor)
FROM students WHERE sid = id);
END//
DELIMITER ;
-- 调用函数
SELECT get_student_info_by_sid(8);

```

调用函数结果：

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822301.png)

##### 4.3.2 自定义函数 2：要求函数体中包含其中一种流程控制语句，要求输入学生学号sid、课程编号，显示学生姓名、课程名称、成绩是否及格（即成绩>=60)

```sql

DROP FUNCTION IF EXISTS get_student_scores_by_id;

DELIMITER //
CREATE DEFINER = CURRENT_USER FUNCTION get_student_scores_by_id(sid INT, cid INT)
RETURNS VARCHAR(300)
DETERMINISTIC
BEGIN
	-- 多个变量要分开声明，否则会报错
	DECLARE score INT;
	DECLARE name VARCHAR(20);
	DECLARE course_name VARCHAR(20);
	SELECT sc.score INTO score
	FROM scores AS sc
	WHERE sc.sid = sid AND sc.cid = cid;
	SELECT sname INTO name FROM students AS stu WHERE stu.sid = sid;
	SELECT cname INTO course_name FROM courses AS co WHERE co.cid = cid;
	IF score >= 60 THEN
		RETURN CONCAT(name, '--', course_name, '--', '及格');
	ELSEIF score > 0 AND score < 60 THEN
		RETURN CONCAT(name, '--', course_name, '--', '不及格');
	ELSE
		RETURN '找不到该学生、课程或该学生没有选课！';
	END IF;
END//
DELIMITER ;

-- 调用函数
SELECT get_student_scores_by_id(1, 2);
```

调用函数结果：

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822734.png)



#### 4.5 创建触发器

##### 4.5.1 创建一个更新学生学分的触发器，如果该学生分数>=60，则给该学生加上这门课的学分

> 语法
> create trigger triggerName
> after/before insert/update/delete on 表名 for each row #这句话在mysql是固定的 begin
> sql语句;
> end;

```sql

DROP TRIGGER IF EXISTS update_credit_point;

DELIMITER //
CREATE TRIGGER update_credit_point
AFTER INSERT ON scores FOR EACH ROW
BEGIN 
	DECLARE points INT;
	SELECT co.credit_point INTO points FROM courses AS co WHERE co.cid = new.cid;
	IF new.score >= 60 THEN
		UPDATE students SET credit_points = credit_points + points
		WHERE sid = new.sid;
	END IF;
END//
DELIMITER ;


-- 测试数据
SELECT * FROM students WHERE sid < 3;
INSERT INTO scores VALUES
(1, 4, 77),
(2, 4, 55);
SELECT * FROM students;

```

测试结果:

![在这里插入图片描述](https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251822465.png)





## 扩展

### 1. 索引相关

#### 1.1 索引方法的分类

1. 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引
2. 从应用层次来分：普通索引，唯一索引，复合索引
   - 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
   - 唯一索引：索引列的值必须唯一，但允许有空值
   - 复合索引：即一个索引包含多个列
3. 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引
   - 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
   - 非聚簇索引：不是聚簇索引，就是非聚簇索引。

#### 1.2 索引的底层实现

相关连接：[索引的底层实现](https://zhuanlan.zhihu.com/p/87011871)







